title: 椭圆曲线加密
tags: 密码学
categories: Go
copyright: true
mathjax: true
---

区块链中主要使用了公钥加密算法，具体为椭圆曲线加密及其一系列算法。如大家经常听到的**ECC**，**ECDH**，**ECDSA**。其中**ECC**为椭圆曲线密码的缩写(Elliptic Curve Cryptography)。其它的两个为基于椭圆曲线的密码算法和签名算法。

在椭圆曲线密码流行前，一些其它的公钥密码方案得到大量使用，如著名的 RSA密码，DSA 和DH。它们都是由有限域上的模运算的一些困难问题而设计出的。并且注意到**DH** 和上面的**ECDH**有两个相同的字母，实际上这两种算法是非常相似的。
**DH**表示的是Diffie Hellman算法，它是基于有限域上的离散对数问题而设计的，所以顾名思义**ECDH **可以理解为椭圆曲线上上的Diffie Hellman算法，即基于椭圆曲线上的离散对数问题设计的。

##有限域和离散对数
有限域简单来说是一个有限个元素组成的集合，最简单的有限域整数模一个素数$p$，就可以得到一个有限域记为$\mathbb{Z}/p$或者$\mathbb{F}_p$。如$\mathbb{F}_5=\{0,1,2,3,4\} $. 容易看出有限域$\mathbb{F}_p$包含 **所有从0到$p-1$的整数**。

域中定义两种运算：加法(+)和乘法(*),它们对于有限域中的元素来说都是封闭的且满足结合律和交换律。对乘法存在单位元即相当于整数中的1，存在逆元则保证了有限域中的元素做除法运算得到的结果还在有限域中达到封闭的要求。如：$\mathbb{F}_5$中$2*3\bmod 5 =1$,则$2$的逆元为$3$。$3$依然是在有限域中的
那么显然所有的整数不作成一个有限域因为任意一个整数的逆为一个分数。对加法同样定义逆运算即减法，因此需要零元即$0$.

以$\mathbb{F}_{5}$为例具体看一下这些运算：

* 加法：$(1+2)\bmod5=3$
* 减法：$(1-2)\bmod5=4$
* 加法逆：因为$(2+(-2)) \bmod5=(2+3)\bmod5=0$所以$-2\bmod5=3$
* 乘法：$2*4\bmod5=3$
* 除法：$(2\div3)\bmod5=4$,除法运算开销很大实际上是通过先计算逆元再计算乘法得到的$2*3^{-1}\bmod5=2*2\bmod5=4$
* 乘法逆：因为$2*2^{-1}\bmod5=2*3\bmod5=1$所以$2^{-1}\bmod5=3$

可以看到有限域上的所有运算最终都要模上素数$p$,而可以看到加法的逆元算和乘法的逆元算实际上是求解$(2-x)\bmod5=0$和$2*x\bmod 5=1$得到的。前者很容易计算，但后者就需要很大的开销了。同样我们可以看到为什么要选用素数$p$,因为如果选取一个合数比如$4$,则$2*x\bmod 4 = 1$是没有解的，那么自然不能满足封闭的要求。

###除法运算
上面的例子中由于$p=5$是一个很小的素数容易看出结果，但在密码设计中$p$通常是一个很大的素数，那么除法的计算就很难看出了。如计算$2\div3\bmod 5$,可以转换成乘法计算$2*3^{-1}\bmod5$，实际上只需要求被乘数$3$的逆就可以了，即解方程$3*x\bmod 5=1$。

通常使用扩展欧几里得算法[(extended Eucilidean algorithm )](https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm)求某个元素的的乘法逆元。
```go
//欧几里得算法求最大公因数,(x,y)和（x,xmody）的最大公约数相同
func gcd(x,y int) int{
	for y!=0{
		x,y=y,x%y
	}
	return x
}
//扩展欧几里得算法，对于x,y必存在整数u，v使得gcd(x,y)=u*x+v*y
//档x,y互素时则返回的u即满足x*u mod y=1
func extendeGcd(x, y int) (gcd, u, v int) {
         u, old_u := 0, 1
         v, old_v := 1, 0
         r, old_r := y, x
 
         for r != 0 {
                 quotient := int(old_r / r)
                 old_r, r = r, old_r-quotient*r
                 old_u, u = u, old_u-quotient*u
                 old_v, v = v, old_v-quotient*v
         }
 
         return old_r, old_u, old_v
 }
```
###离散对数问题
上面已经介绍了有限域的定义，可以看到有限域上的元素对于定义的两种运算乘法和加法都是封闭的。那么现在我们考虑一下,




