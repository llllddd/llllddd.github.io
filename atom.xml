<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LoveLotus</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ldlovezyh.cn/"/>
  <updated>2019-03-06T09:42:28.606Z</updated>
  <id>http://ldlovezyh.cn/</id>
  
  <author>
    <name>DianL</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RLP编码与区块解析</title>
    <link href="http://ldlovezyh.cn/2018/08/08/RLP%E7%BC%96%E7%A0%81%E4%B8%8E%E5%8C%BA%E5%9D%97%E8%A7%A3%E6%9E%90/"/>
    <id>http://ldlovezyh.cn/2018/08/08/RLP编码与区块解析/</id>
    <published>2018-08-07T16:00:00.000Z</published>
    <updated>2019-03-06T09:42:28.606Z</updated>
    
    <content type="html"><![CDATA[<p>以太坊在网络传输过程中数据是经过RLP编码之后进行传输的。</p><h2 id="区块广播"><a href="#区块广播" class="headerlink" title="区块广播"></a>区块广播</h2><p>区块广播以及区块的同步过程均涉及到RLP编码。</p><p>当区块由本地矿工封印之后，同时会向信道中传入一个事件，包含了事件的时间，以及数据即<code>type.block</code>类型的区块结构体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TypeMuxEvent <span class="keyword">struct</span> &#123;</span><br><span class="line">Time time.Time</span><br><span class="line">Data <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，<code>worker</code>维护的一个事件管理器，会将新挖出的区块作为一个事件开始进行广播。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *worker)</span><span class="title">wait</span><span class="params">()</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">self.mux.Post(core.NewMinedBlockEvent&#123;Block: block&#125;)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>广播的过程即，将新区块事件，添加到一个事件队列内，该队列将分派，不同类型事件给订阅此信道的接受者。同时将新区快事件添加到广播信道内。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TypeMuxSubscription <span class="keyword">struct</span> &#123;</span><br><span class="line">mux     *TypeMux</span><br><span class="line">created time.Time</span><br><span class="line">closeMu sync.Mutex</span><br><span class="line">closing <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">closed  <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// these two are the same channel. they are stored separately so</span></span><br><span class="line"><span class="comment">// postC can be set to nil without affecting the return value of</span></span><br><span class="line"><span class="comment">// Chan.</span></span><br><span class="line">postMu sync.RWMutex</span><br><span class="line">readC  &lt;-<span class="keyword">chan</span> *TypeMuxEvent</span><br><span class="line">postC  <span class="keyword">chan</span>&lt;- *TypeMuxEvent</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，新区块广播的初始工作已经完成。</p><p>以太坊服务在启动时，同时会开启P2P服务，具体为创建一个管理相关协仪结构体。</p><p>开启节点服务后，即开始监听相关事件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Ethereum)</span> <span class="title">Start</span><span class="params">(srvr *p2p.Server)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// Start the bloom bits servicing goroutines</span></span><br><span class="line">s.startBloomHandlers()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start the RPC service</span></span><br><span class="line">s.netRPCService = ethapi.NewPublicNetAPI(srvr, s.NetVersion())</span><br><span class="line"></span><br><span class="line"><span class="comment">// Figure out a max peers count based on the server limits</span></span><br><span class="line">maxPeers := srvr.MaxPeers</span><br><span class="line"><span class="keyword">if</span> s.config.LightServ &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> s.config.LightPeers &gt;= srvr.MaxPeers &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"invalid peer config: light peer count (%d) &gt;= total peer count (%d)"</span>, s.config.LightPeers, srvr.MaxPeers)</span><br><span class="line">&#125;</span><br><span class="line">maxPeers -= s.config.LightPeers</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Start the networking layer and the light server if requested</span></span><br><span class="line">s.protocolManager.Start(maxPeers)</span><br><span class="line"><span class="keyword">if</span> s.lesServer != <span class="literal">nil</span> &#123;</span><br><span class="line">s.lesServer.Start(srvr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>节点服务，包含对相关信道的建立，远程调用服务的建立，以及网络层面上对相关服务器节点P2P协议的启用。</p><p>启用节点协议，即由协议管理器，建立对应的事件监听信道。实际上对应了三个循环:</p><div class="note info"><ol><li>广播新出现的交易对象。</li><li>广播新挖掘出现的区块。</li><li>定时与相邻个体进行区块链的强制同步。</li><li>将新出现的交易对象均匀的同步给相邻个体。</li></ol></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *ProtocolManager)</span> <span class="title">Start</span><span class="params">(maxPeers <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">pm.maxPeers = maxPeers</span><br><span class="line"></span><br><span class="line"><span class="comment">// broadcast transactions</span></span><br><span class="line">pm.txsCh = <span class="built_in">make</span>(<span class="keyword">chan</span> core.NewTxsEvent, txChanSize)</span><br><span class="line">pm.txsSub = pm.txpool.SubscribeNewTxsEvent(pm.txsCh)</span><br><span class="line"><span class="keyword">go</span> pm.txBroadcastLoop()</span><br><span class="line"></span><br><span class="line"><span class="comment">// broadcast mined blocks</span></span><br><span class="line">pm.minedBlockSub = pm.eventMux.Subscribe(core.NewMinedBlockEvent&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> pm.minedBroadcastLoop()</span><br><span class="line"></span><br><span class="line"><span class="comment">// start sync handlers</span></span><br><span class="line"><span class="keyword">go</span> pm.syncer()</span><br><span class="line"><span class="keyword">go</span> pm.txsyncLoop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建协议管理结构体时，其事件多路复用器<code>event.TypeMux</code>为eth客户端在构建挖矿结构体时的公用对象。当启用服务时，协议管理会将其成员<code>event.TypeMux</code>订阅一个新区块事件，并且事件队列添加到成员中。</p><p>监听新出现区块的循环会扫描，事件队列的信道，如果是一个新区块事件，那么将广播区块，这里的事件队列，与挖矿过程中区块事件存储的是相同的队列。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *ProtocolManager)</span> <span class="title">minedBroadcastLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// automatically stops if unsubscribe</span></span><br><span class="line"><span class="keyword">for</span> obj := <span class="keyword">range</span> pm.minedBlockSub.Chan() &#123;</span><br><span class="line"><span class="keyword">switch</span> ev := obj.Data.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> core.NewMinedBlockEvent:</span><br><span class="line">pm.BroadcastBlock(ev.Block, <span class="literal">true</span>)  <span class="comment">// First propagate block to peers</span></span><br><span class="line">pm.BroadcastBlock(ev.Block, <span class="literal">false</span>) <span class="comment">// Only then announce to the rest</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>广播的过程实际上是，将新区块信息扩散至其它节点的过程。</p><p>具体流程为:</p><blockquote><ol><li>选取节点队列中不包含此区块hash任务的节点。</li><li>计算totaldifficulty</li><li>将区块发送至其它子节点</li></ol></blockquote><p>将新区块信息发送至其它节点的过程异步发送：</p><blockquote><ol><li>将区块与总困难值添加至广播事件队列中。</li><li>将新区哈希添加至节点已知区块队列中。</li></ol></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *peer)</span> <span class="title">AsyncSendNewBlock</span><span class="params">(block *types.Block, td *big.Int)</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> p.queuedProps &lt;- &amp;propEvent&#123;block: block, td: td&#125;:</span><br><span class="line">p.knownBlocks.Add(block.Hash())</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">p.Log().Debug(<span class="string">"Dropping block propagation"</span>, <span class="string">"number"</span>, block.NumberU64(), <span class="string">"hash"</span>, block.Hash())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么包含此节点的节点，便会处理节点中的信息。与此节点握手。同时处理节点发来的信息。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *ProtocolManager)</span> <span class="title">handle</span><span class="params">(p *peer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>与节点握手的过程中，会注册该节点，该节点将其事件队列中的信息广播。发送区块节总难度的信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ps *peerSet)</span> <span class="title">Register</span><span class="params">(p *peer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">ps.lock.Lock()</span><br><span class="line"><span class="keyword">defer</span> ps.lock.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ps.closed &#123;</span><br><span class="line"><span class="keyword">return</span> errClosed</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> _, ok := ps.peers[p.id]; ok &#123;</span><br><span class="line"><span class="keyword">return</span> errAlreadyRegistered</span><br><span class="line">&#125;</span><br><span class="line">ps.peers[p.id] = p</span><br><span class="line"><span class="keyword">go</span> p.broadcast()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *peer)</span> <span class="title">broadcast</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> txs := &lt;-p.queuedTxs:</span><br><span class="line"><span class="keyword">if</span> err := p.SendTransactions(txs); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">p.Log().Trace(<span class="string">"Broadcast transactions"</span>, <span class="string">"count"</span>, <span class="built_in">len</span>(txs))</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> prop := &lt;-p.queuedProps:</span><br><span class="line"><span class="keyword">if</span> err := p.SendNewBlock(prop.block, prop.td); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">p.Log().Trace(<span class="string">"Propagated block"</span>, <span class="string">"number"</span>, prop.block.Number(), <span class="string">"hash"</span>, prop.block.Hash(), <span class="string">"td"</span>, prop.td)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> block := &lt;-p.queuedAnns:</span><br><span class="line"><span class="keyword">if</span> err := p.SendNewBlockHashes([]common.Hash&#123;block.Hash()&#125;, []<span class="keyword">uint64</span>&#123;block.NumberU64()&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">p.Log().Trace(<span class="string">"Announced block"</span>, <span class="string">"number"</span>, block.Number(), <span class="string">"hash"</span>, block.Hash())</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> &lt;-p.term:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送的信息包含两部分内容:</p><div class="note info"><ol><li>信息类型: 新区块则为0x07</li><li>RLP编码后的信息，编码的内容为区块与总困难值。</li></ol></div><p>处理信息的过程是根据信息类型来采取对应的处理机制。<br>处理新区块的策略为:</p><blockquote><ol><li>将信息解码</li><li>将发送新区块的节点标记。</li><li>将区块加入到获取队列中。</li></ol></blockquote><p>将获取队列中的区块验证并插入到本地区块链中。</p><hr><h2 id="RLP编码"><a href="#RLP编码" class="headerlink" title="RLP编码"></a>RLP编码</h2><p>递归前缀长度( Recursive Length Prefix)编码，是一种对任意结构化的数据进行序列化的方法。</p><p>定义了RLP编码规则的对象有两类，byte数组和bytes数组的数组。</p><p>byte数组的编码规则可以适用于可以转换为byte类型的其它变量。如string，int，big.int等。</p><p>而像struct，map等这类复杂类型则可以转换为byte数组的数组，它们适用于第二类编码规则。</p><hr><h3 id="byte编码规则"><a href="#byte编码规则" class="headerlink" title="[]byte编码规则"></a>[]byte编码规则</h3><ol><li>若长度为1字节且值小于128，编码值不变。</li><li>若byte数组长度小于56字节，长度+128+数组本身。</li><li>数组长度的大端序表示，大端序表示数组长度的数字。183+大端序数组长度数字+数组长度+数组本身.</li></ol><p>规则1</p><blockquote><p>[]byte{1}编码后的结果为1<br>[]byte{0x7E}编码后的结果为7E<br>uint32(127)编码后的结果为7E<br>big.NewInt(1)编码后的结果为1<br>string(‘a’)编码后的结果为61</p></blockquote><p>规则2</p><blockquote><p>[]byte{}编码后的结果为80<br>big.NewInt(0)编码后的结果为80<br>[]byte{1,2,3}编码后的结果为83010203<br>[]byte{0x80}编码后的结果为8180<br>string(“dog”)编码后的结果为83646F67</p></blockquote><p>规则3</p><blockquote><p>规则3首先将数组长度表示出来，加上前缀183。<br>理论上可以表示最大的数组长度为$2^64$字节。<br>256个a组成的字符串编码:<br>首先字符串长度为256：大端序数字为 0100需要2字节来表示，因此前缀为185<br>所以RLP编码后的结果为:<br>18501006161…</p></blockquote><hr><h3 id="byte编码规则-1"><a href="#byte编码规则-1" class="headerlink" title="[][]byte编码规则"></a>[][]byte编码规则</h3><p>对于一些其它的复杂结构体，以及基础类型的slice都可以转换为[]byte数组列表，因为其数据成员都可以转换为[]byte类型使用第一类的转换规则。</p><div class="note info"><ol><li>若数组总长度小于56，192+长度+数组</li><li>其它，大端序表示数组长度的数字。247+大端序数组长度数字+数组长度+数组本身.</li></ol></div><p>规则1</p><blockquote><p>[]uint{} 编码后的结果为: “C0”<br>[]uint{1,2,3}编码后的结果为:”C3010203“<br>[]string{“aaa”,”bbb”}编码后的结果为:”C88361616183626262”<br>struct{uint : 5, string : “aaa”}编码后的结果为：<br>C50583616161</p></blockquote><hr><h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><p>由编码规则可以知道，第一个字节记录了编码数据的长度，并且根据大小可以判断数据属于那种编码规则以及解码数据长度的大小是多少。</p><p>记第一个字节为L<br>L的大小小于192则是由第一类编码规则解码。</p><blockquote><ol><li>若$L\in[0,128)$, 表示一个字节本身。</li><li>若$L\in[128,184)$, 表示长度不超过55字节的数组长度为L-128.</li><li>若$L\in[184,192)$, 最长能表示为$2^{64}$字节长的数组，长度为从第二个字节起长度为L-183的整数。</li><li>若$L\in[192,248)$ 编码后长度小于56的byte数组列表，长度为L-192</li><li>若$L\in[248,256)$ 编码后长度大于56的byte数组列表，长度为从第二个字节起长度为L-247的整数。</li></ol></blockquote><p>这样对于复杂的结构体只要其成员变量的顺序不变，就可以根据编码后的数据解码，依次得到对应成员的数据，进而得到远结构体。</p><p>区块结构体包含了大量的数据成员，但是根据编码规则最终可以解析得到原区块的数据。</p><p>如区块数据：</p><blockquote><p>f90260|f901f9|a0|83cafc574e1f51ba9dc0568fc617a08ea2429fb384059c972f13b19fa1c8dd55|<br>a0|1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347|94|<br>8888f1f195afa192cfee860698584c030f4c9db1|a0|<br>ef1552a40b7165c3cd773806b9e0c165b75356e0314bf0706f279c729f51e017|a0|<br>5fe50b260da6308036625b850b5d6ced6d0a9f814c0688bc91ffb7b7a3a54b67|a0|<br>bc37d79753ad738a6dac4921e57392f145d8887476de3f783dfa7edae9283e52|b90100|<br>0000000000000000000000000000000000000000000000000000000000000000000000000<br>0000000000000000000000000000000000000000000000000000000000000000000000000<br>0000000000000000000000000000000000000000000000000000000000000000000000000<br>0000000000000000000000000000000000000000000000000000000000000000000000000<br>0000000000000000000000000000000000000000000000000000000000000000000000000<br>0000000000000000000000000000000000000000000000000000000000000000000000000<br>00000000000000000000000000000000000000000000000000000000000000000000000000|<br>83|020000|01|83|2fefd8|82|5208|84|5506eb07|80|a0|<br>bd4472abb6659ebe3ee06ee4d7b72a00a9f4d001caca51342001075469aff498|88|<br>a13a5a8c8f2bb1c4|f8|61|f8|5f|80|0a|82|c350|94|<br>095e7baea6a6c7c4c2dfeb977efac326af552d87|0a|80|1b|a0|<br>9bea4c4daac7c7c52e093e6a4c35dbbcf8856f1af7b059ba20253e70848d094f|a0|<br>8a8fae537ce25ed8cb5af9adac3f141af69bd515bd2ba031522df09b97dd72b1|c0</p></blockquote><p>可以根据编码信息得到完整的type.block结构体所有信息。</p><p>首先 f9 249 表示整个区块编码后的尺寸长度为2字节，所以0260为608字节。</p><p>接下来第一个被编码的为区块头 f901f9表明区块头的大小为505字节。<br>区块头中第一个被编码的为ParentHash: a0为160表明hash为32字节因此ParentHash为: 83cafc574e1f51ba9dc0568fc617a08ea2429fb384059c972f13b19fa1c8dd55</p><p>接下来为UncleHash 同样 a0表明UncleHash为32字节:<br>1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347</p><p>接下来为Coinbase这是一个账户地址为20字节,94表示长度为20字节:<br>8888f1f195afa192cfee860698584c030f4c9db1<br>依次类推直到区块头解析完毕。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Header <span class="keyword">struct</span> &#123;</span><br><span class="line">ParentHash  common.Hash    <span class="string">`json:"parentHash"       gencodec:"required"`</span></span><br><span class="line">UncleHash   common.Hash    <span class="string">`json:"sha3Uncles"       gencodec:"required"`</span></span><br><span class="line">Coinbase    common.Address <span class="string">`json:"miner"            gencodec:"required"`</span></span><br><span class="line">Root        common.Hash    <span class="string">`json:"stateRoot"        gencodec:"required"`</span></span><br><span class="line">TxHash      common.Hash    <span class="string">`json:"transactionsRoot" gencodec:"required"`</span></span><br><span class="line">ReceiptHash common.Hash    <span class="string">`json:"receiptsRoot"     gencodec:"required"`</span></span><br><span class="line">Bloom       Bloom          <span class="string">`json:"logsBloom"        gencodec:"required"`</span></span><br><span class="line">Difficulty  *big.Int       <span class="string">`json:"difficulty"       gencodec:"required"`</span></span><br><span class="line">Number      *big.Int       <span class="string">`json:"number"           gencodec:"required"`</span></span><br><span class="line">GasLimit    <span class="keyword">uint64</span>         <span class="string">`json:"gasLimit"         gencodec:"required"`</span></span><br><span class="line">GasUsed     <span class="keyword">uint64</span>         <span class="string">`json:"gasUsed"          gencodec:"required"`</span></span><br><span class="line">Time        *big.Int       <span class="string">`json:"timestamp"        gencodec:"required"`</span></span><br><span class="line">Extra       []<span class="keyword">byte</span>         <span class="string">`json:"extraData"        gencodec:"required"`</span></span><br><span class="line">MixDigest   common.Hash    <span class="string">`json:"mixHash"          gencodec:"required"`</span></span><br><span class="line">Nonce       BlockNonce     <span class="string">`json:"nonce"            gencodec:"required"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">区块结构体的相关代码：</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">struct</span> &#123;</span><br><span class="line">header       *Header</span><br><span class="line">uncles       []*Header</span><br><span class="line">transactions Transactions</span><br><span class="line"></span><br><span class="line"><span class="comment">// caches</span></span><br><span class="line">hash atomic.Value</span><br><span class="line">size atomic.Value</span><br><span class="line"></span><br><span class="line"><span class="comment">// Td is used by package core to store the total difficulty</span></span><br><span class="line"><span class="comment">// of the chain up to and including the block.</span></span><br><span class="line">td *big.Int</span><br><span class="line"></span><br><span class="line"><span class="comment">// These fields are used by package eth to track</span></span><br><span class="line"><span class="comment">// inter-peer block relay.</span></span><br><span class="line">ReceivedAt   time.Time</span><br><span class="line">ReceivedFrom <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">交易结构体相关代码：</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Transaction <span class="keyword">struct</span> &#123;</span><br><span class="line">data txdata</span><br><span class="line"><span class="comment">// caches</span></span><br><span class="line">hash atomic.Value</span><br><span class="line">size atomic.Value</span><br><span class="line">from atomic.Value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> txdata <span class="keyword">struct</span> &#123;</span><br><span class="line">AccountNonce <span class="keyword">uint64</span>          <span class="string">`json:"nonce"    gencodec:"required"`</span></span><br><span class="line">Price        *big.Int        <span class="string">`json:"gasPrice" gencodec:"required"`</span></span><br><span class="line">GasLimit     <span class="keyword">uint64</span>          <span class="string">`json:"gas"      gencodec:"required"`</span></span><br><span class="line">Recipient    *common.Address <span class="string">`json:"to"       rlp:"nil"`</span> <span class="comment">// nil means contract creation</span></span><br><span class="line">Amount       *big.Int        <span class="string">`json:"value"    gencodec:"required"`</span></span><br><span class="line">Payload      []<span class="keyword">byte</span>          <span class="string">`json:"input"    gencodec:"required"`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Signature values</span></span><br><span class="line">V *big.Int <span class="string">`json:"v" gencodec:"required"`</span></span><br><span class="line">R *big.Int <span class="string">`json:"r" gencodec:"required"`</span></span><br><span class="line">S *big.Int <span class="string">`json:"s" gencodec:"required"`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This is only used when marshaling to JSON.</span></span><br><span class="line">Hash *common.Hash <span class="string">`json:"hash" rlp:"-"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以太坊在网络传输过程中数据是经过RLP编码之后进行传输的。&lt;/p&gt;
&lt;h2 id=&quot;区块广播&quot;&gt;&lt;a href=&quot;#区块广播&quot; class=&quot;headerlink&quot; title=&quot;区块广播&quot;&gt;&lt;/a&gt;区块广播&lt;/h2&gt;&lt;p&gt;区块广播以及区块的同步过程均涉及到RLP编码。&lt;/
      
    
    </summary>
    
      <category term="以太坊" scheme="http://ldlovezyh.cn/categories/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
    
      <category term="以太坊" scheme="http://ldlovezyh.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
      <category term="GO" scheme="http://ldlovezyh.cn/tags/GO/"/>
    
      <category term="椭圆曲线加密" scheme="http://ldlovezyh.cn/tags/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>以太坊Pow共识算法</title>
    <link href="http://ldlovezyh.cn/2018/08/01/%E4%BB%A5%E5%A4%AA%E5%9D%8APOW%E7%AE%97%E6%B3%95Ethash/"/>
    <id>http://ldlovezyh.cn/2018/08/01/以太坊POW算法Ethash/</id>
    <published>2018-07-31T16:00:00.000Z</published>
    <updated>2019-03-06T09:43:14.962Z</updated>
    
    <content type="html"><![CDATA[<p>以太坊的共识算法采用Ethash方案。</p><p>通过待挖掘区块的高度，计算出难度值，将难度值告知矿工，矿工通过共识算法中计算，来完成对应难度的挖掘，达到工作量的证明。</p><p>为了使得工作量证明是有效的，那么共识算法的设计上必然是易于验证，难于改变的。</p><p>所有矿工节点，都尝试通过Ethash算法解决给定难度的问题，并且随着区块高度的增加，参数也会随之增大从而带来挖矿难度的增加。</p><hr><h2 id="挖矿难度"><a href="#挖矿难度" class="headerlink" title="挖矿难度"></a>挖矿难度</h2><p>以太坊到目前为止经历三次难度计算方法的调整，分别对应以太坊的三个版本Frontier，Homestead和Byzantium。</p><p>目前，以太坊处于Byzantium版本。挖矿难度计算主要依赖于以下几点：</p><div class="note info"><ol><li>父块难度，时间戳以及子块时间戳。</li><li>子块难度 = 父块难度 + 调整因子 + 主因子 </li></ol></div><p>$调整因子 = \frac{父块难度}{2048} * MAX ( 1 - \frac{子块时间戳 - 父块时间戳}{10}, -99)$</p><p>$主因子 = 2^{\frac{区块高度} {100000} - 2}$</p><p>这样一个新的区块的难度，就可以跟据父块的难度计算的到。同时主因子成指数级上升，因此随着区块高度的不断增加，挖矿的难度也会不断上升。</p><h2 id="Dataset的生成"><a href="#Dataset的生成" class="headerlink" title="Dataset的生成"></a>Dataset的生成</h2><p>以太坊中的hashmoto算法，需要首先产生一个dataset，而dataset的生成由依赖于一个cache。</p><p>cache 为一连串64字节哈希值组成的数组，它的尺寸随着区块高度的增加而增大，意味着计算所需要的内存增加。dataset同样尺寸也会随着区块高度的增加而增大。</p><p>尺寸不断改变的设计，使得区块的挖掘越来越困难。</p><h3 id="计算Dataset和Cache的尺寸"><a href="#计算Dataset和Cache的尺寸" class="headerlink" title="计算Dataset和Cache的尺寸"></a>计算Dataset和Cache的尺寸</h3><p>Ethash中cache和dataset的大小依赖于区块的epoch，每30000个区块作为一个epoch。</p><p>dataset的尺寸，每隔一个epoch增长8MB，而cache的尺寸，每隔一个epoch增长128KB。同时cache和dataset中都存的为64字节哈希值。</p><p>为了避免规律而导致循环的行为，元素的个数要保证为素数。代码中将前2048个epoch的相关尺寸已经作成了表，当超过后则需要计算。目前以太坊区块的高度处于第203epoch。</p><p>以太坊中计算的相关代码为:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calcCacheSize</span><span class="params">(epoch <span class="keyword">int</span>)</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line">        size := cacheInitBytes + cacheGrowthBytes*<span class="keyword">uint64</span>(epoch) - hashBytes</span><br><span class="line">        <span class="keyword">for</span> !<span class="built_in">new</span>(big.Int).SetUint64(size / hashBytes).ProbablyPrime(<span class="number">1</span>) &#123;                                                         </span><br><span class="line">                size -= <span class="number">2</span> * hashBytes</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calcDatasetSize</span><span class="params">(epoch <span class="keyword">int</span>)</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line">        size := datasetInitBytes + datasetGrowthBytes*<span class="keyword">uint64</span>(epoch) - mixBytes</span><br><span class="line">        <span class="keyword">for</span> !<span class="built_in">new</span>(big.Int).SetUint64(size / mixBytes).ProbablyPrime(<span class="number">1</span>) &#123;                                                         </span><br><span class="line">                size -= <span class="number">2</span> * mixBytes</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生成cache"><a href="#生成cache" class="headerlink" title="生成cache"></a>生成cache</h3><p>dataset在结构上一个有向无环图，即每一个字节点可以有多个父节点，并且是单向的。</p><p>为了生成dataset，需要首先生成cache，cache的计算依赖于它的尺寸和种子。</p><h4 id="种子的生成"><a href="#种子的生成" class="headerlink" title="种子的生成"></a>种子的生成</h4><p>生成cache的种子是一段32字节哈希值，它由Kccak256算法计算得到。</p><p>种子的计算，也是根据区块所属的epoch，每个epoch的种子不同的。</p><p>第一个epoch的种子值为32字节的0，而后每一个epoch的种子都是前一个epoch种子的Keccak-256哈希值。</p><h4 id="RandMemoHash"><a href="#RandMemoHash" class="headerlink" title="RandMemoHash"></a>RandMemoHash</h4><p>cache的生成过程主要有两部分:<br><div class="note info"><p>计算初始数据集</p><ol><li>由对应epoch的种子，通过Keccak512算法生成64字节的哈希值。</li><li>依次通过前一次计算的哈希值再进行哈希，最终得到cache尺寸的数据。</li></ol></div></p><div class="note info"><p>通过RanMenoHash算法得到最终的cache</p><ol><li>记初始的数据集为M, 64字节哈希值得个数为N。</li><li>递推计算cache中的每个元素，共经过三轮计算。<br>$M[0] = Keccak512(M[N-1]\bigoplus M[(M[0]\bmod N)])$<br>$M[1] = Keccak512(M[0]\bigoplus M[(M[1]\bmod N)])$<br>$\cdots$<br>$M[N-1] = Keccak512(M[N-2]\bigoplus M[(M[N-1]\bmod N)])$</li></ol></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateCache</span><span class="params">(dest []<span class="keyword">uint32</span>, epoch <span class="keyword">uint64</span>, seed []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">         <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; cacheRounds; i++ &#123;</span><br><span class="line">                 <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; rows; j++ &#123;</span><br><span class="line">                         <span class="keyword">var</span> (</span><br><span class="line">                                 srcOff = ((j - <span class="number">1</span> + rows) % rows) * hashBy\</span><br><span class="line">     tes</span><br><span class="line">                                 dstOff = j * hashBytes</span><br><span class="line">                                 xorOff = (binary.LittleEndian.Uint32(cach\</span><br><span class="line">     e[dstOff:]) % <span class="keyword">uint32</span>(rows)) * hashBytes</span><br><span class="line">                         )</span><br><span class="line">                         bitutil.XORBytes(temp, cache[srcOff:srcOff+hashBy\</span><br><span class="line">     tes], cache[xorOff:xorOff+hashBytes])</span><br><span class="line">keccak512(cache[dstOff:], temp)</span><br><span class="line"></span><br><span class="line">                         atomic.AddUint32(&amp;progress, <span class="number">1</span>)</span><br><span class="line">                 &#125;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><p>这样，通过迭代计算最终得到了生成dataset所需要的cache。</p><h3 id="计算Dataset中的元素"><a href="#计算Dataset中的元素" class="headerlink" title="计算Dataset中的元素"></a>计算Dataset中的元素</h3><p>dataset中的元素同样为哈希值，每一元素都由256个cache中的元素得到。</p><p>记dataset为D,元素个数为N, cache 为 C。dataset中第i个哈希值的计算过程为：</p><div class="note info"><ol><li>计算初始值 $Mix = Keccak512(C[i \bmod N] \bigoplus i)$ </li><li>经过256轮的迭代计算，每次都会加入一个cache中的元素：<br>$P_0 = FNV(i\bigoplus0 , Mix[0 \bmod 16 : 0\bmod 16 +4 ])$<br>$Mix_0 = FNV(Mix,C[P_0])$<br>$P[1] = FNV(i \bigoplus1 , Mix_0[1 \bmod 16 : 1\bmod 16 +4 ]) $<br>$Mix_1 = FNV(Mix_0,C[P_1])$<br>$\cdots$<br>$P_{255} = FNV(i\bigoplus255 , Mix_{255}[255\bmod 16: 255\bmod 16 + 4])$<br>$Mix_{255} = FNV(Mix_{254},C[P_{255}])$</li><li>返回64字节哈希: $Keccak512(Mix_{255})$</li></ol></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateDatasetItem</span><span class="params">(cache []<span class="keyword">uint32</span>, index <span class="keyword">uint32</span>, keccak512 hasher)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">         <span class="comment">// Convert the mix to uint32s to avoid constant bit shifting      </span></span><br><span class="line">         intMix := <span class="built_in">make</span>([]<span class="keyword">uint32</span>, hashWords)</span><br><span class="line">         <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(intMix); i++ &#123;</span><br><span class="line">                 intMix[i] = binary.LittleEndian.Uint32(mix[i*<span class="number">4</span>:])</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// fnv it with a lot of random cache nodes based on index         </span></span><br><span class="line">         <span class="keyword">for</span> i := <span class="keyword">uint32</span>(<span class="number">0</span>); i &lt; datasetParents; i++ &#123;</span><br><span class="line">                 parent := fnv(index^i, intMix[i%<span class="number">16</span>]) % rows</span><br><span class="line">                 fnvHash(intMix, cache[parent*hashWords:])</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// Flatten the uint32 mix into a binary one and return            </span></span><br><span class="line">         <span class="keyword">for</span> i, val := <span class="keyword">range</span> intMix &#123;</span><br><span class="line">                 binary.LittleEndian.PutUint32(mix[i*<span class="number">4</span>:], val)</span><br><span class="line">         &#125;</span><br><span class="line">         keccak512(mix, mix)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成的dataset，为之后hashmoto函数调用。</p><h2 id="Hashmoto算法"><a href="#Hashmoto算法" class="headerlink" title="Hashmoto算法"></a>Hashmoto算法</h2><p>Hashmoto函数为矿工在根据区块的难度，进行工作量证明时进行哈希计算的主函数。最终得到64字节的数组，包含32字节的摘要与32字节的哈希值。</p><p>Hashmoto算法的输入有:</p><ul><li>候选区块头的哈希。</li><li>随机选取的nonce。</li><li>dataset的大小。</li><li>从dataset中得到元素的回调函数。</li></ul><p>Hashmoto函数的整体思路为: 从dataset中选取元素，混合得到128字节数组，通过FNV算法再将数组压缩，最终得到输出的32字节digest。</p><h3 id="计算种子"><a href="#计算种子" class="headerlink" title="计算种子"></a>计算种子</h3><div class="note info"><ol><li>32字节的区块头哈希值与8字节nonce，通过Keccak512得到64字节种子。</li><li>初始化Mix(seed,seed)。</li></ol></div><p>由种子经过接下来两个过程得到最终的结果。</p><h3 id="Accesses"><a href="#Accesses" class="headerlink" title="Accesses"></a>Accesses</h3><p> 经过64轮的迭代运算，每次计算都会加入一个dataset中的元素。</p><p>计算过程: </p><blockquote><p> 记dataset为D，128字节元素个数为N,种子s，迭代次数i.<br>   $P_0 = FNV( 0 \bigoplus s , Mix[0 \bmod 32])\bmod N$<br>   $T_0 = (D[2<em>P_0],D[2</em>P_0+1])$<br>   $Mix_0 = FNV(Mix, T_0)$<br>$\cdots$<br>$P_{63} = FNV( 63 \bigoplus s , Mix[63 \bmod 32])\bmod N$<br>   $T_{63} = (D[2<em>P_{63}],D[2</em>P_{63}+1])$<br>   $Mix_{63} = FNV(Mix, T_{63})$</p></blockquote><h3 id="Compress"><a href="#Compress" class="headerlink" title="Compress"></a>Compress</h3><p>通过FNV哈希算法将得到的128字节Mix，压缩为32字节，即每4字节通过Mix中的16字节压缩得到。</p><blockquote><p>Mix数组中每个元素为4字节<br>$Mix[0] =  FNV(FNV(FNV(Mix[0], Mix[1]), Mix[2]), Mix[3])$<br>$Mix[1] =  FNV(FNV(FNV(Mix[4], Mix[5]), Mix[6]), Mix[6])$<br>$\cdots$<br>$Mix[7] =  FNV(FNV(FNV(Mix[32], Mix[33]), Mix[34]), Mix[35])$</p></blockquote><p>最终得到32字节摘要digest。然后通过Keccak256算法计算种子s与digest的哈希值32字节。最终返回digest，与hash共64字节。</p><h3 id="FNV哈希"><a href="#FNV哈希" class="headerlink" title="FNV哈希"></a>FNV哈希</h3><p>以太坊中使用FNV哈希算法，这种算法能块速哈希大量数据并保持较小的冲突率，适用于哈希一些相近的字符串。以太坊中将其作为异或算法的替换。 </p><p>算法中将32比特的数字乘以一个素数再与另一个32比特数字异或。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fnv</span><span class="params">(a, b <span class="keyword">uint32</span>)</span> <span class="title">uint32</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a*<span class="number">0x01000193</span> ^ b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Mine"><a href="#Mine" class="headerlink" title="Mine"></a>Mine</h2><p>挖矿过程实际上是进行工作量证明的矿工通过hashmoto算法寻找满足区块难度的nonce的过程。</p><p>由新区块的难度值可以计算得到，符合目标值哈希的范围：$\frac{2^{256-1}}{Difficulty}$</p><p>若通过hashmoto算法计算得到的哈希值小于目标值，那么将nonce和摘要digest的哈希值Mixdigest组装到区块头中。这样就得到了完整的区块。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以太坊的共识算法采用Ethash方案。&lt;/p&gt;
&lt;p&gt;通过待挖掘区块的高度，计算出难度值，将难度值告知矿工，矿工通过共识算法中计算，来完成对应难度的挖掘，达到工作量的证明。&lt;/p&gt;
&lt;p&gt;为了使得工作量证明是有效的，那么共识算法的设计上必然是易于验证，难于改变的。&lt;/p&gt;

      
    
    </summary>
    
      <category term="以太坊" scheme="http://ldlovezyh.cn/categories/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
    
      <category term="密码学" scheme="http://ldlovezyh.cn/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="以太坊" scheme="http://ldlovezyh.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
      <category term="GO" scheme="http://ldlovezyh.cn/tags/GO/"/>
    
  </entry>
  
  <entry>
    <title>以太坊钱包原理</title>
    <link href="http://ldlovezyh.cn/2018/07/25/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E9%92%B1%E5%8C%85/"/>
    <id>http://ldlovezyh.cn/2018/07/25/以太坊钱包/</id>
    <published>2018-07-24T16:00:00.000Z</published>
    <updated>2019-03-06T09:43:50.196Z</updated>
    
    <content type="html"><![CDATA[<h2 id="钱包的类型"><a href="#钱包的类型" class="headerlink" title="钱包的类型"></a>钱包的类型</h2><p>用户通过钱包来管理账户，账户中包含了账户地址和账户的私钥信息。地址可以接收交易，而私钥在账户发起交易时对交易进行签名。</p><p>用户通过钱包管理账户私钥实现了对加密货币的管理。</p><p>目前钱包主要有两种类型:<br><div class="note info"><p>非确定性钱包(Nodeterministic(Random) Wallet)<br>确定性钱包(Deterministic(Seeded) Wallet)</p></div></p><p>非确定性钱包中，每一个账户包含一个由随机数生成的私钥和通过私钥得到的账户地址。非确定性钱包中每一个账户都有唯一对应的地址和私钥。</p><p><img src="http://wx2.sinaimg.cn/mw690/844f0132gy1furoikzhb2j20ga0awmxi.jpg" alt="Alt text"></p><p>确定性钱包中，账户的私钥可以派生出若干子密钥对。子密钥对中的公钥可以作为该账户地址，而对应的私钥可对交易签名。确定性钱包中每一个账户，可以有多个账户地址，及对应的私钥。并且这些地址和私钥都可以通过账户的主密钥导出。</p><p>由于确定性钱包中一个账户可以得到多个有效账户地址。对相应地址的交易进行签名时只需由主密钥导出对应私钥即可。省去了非确定性钱包中对每一个账户都要维护一对密钥的麻烦。目前更为常用的是确定性钱包。</p><p><img src="http://wx2.sinaimg.cn/mw690/844f0132gy1furoildhzij20fw09zjs4.jpg" alt="Alt text"></p><hr><h2 id="非确定性钱包"><a href="#非确定性钱包" class="headerlink" title="非确定性钱包"></a>非确定性钱包</h2><p>非确定性钱包也叫随机钱包，钱包中的每一个账户都会有一个与之对应的用户私钥。</p><p>为保证私钥的安全性，本地私钥文件都是通过加密算法(如AES算法)，加密之后存储的。</p><p>这种钱包的缺点在于，若用户有多个账户，则在钱包备份与转移时，需要处理大量的私钥文件，增加了用户的负担以及私钥丢失的可能。</p><p>钱包中账户的地址及私钥由椭圆曲线加密算法得到，生成私钥的种子是由伪随机数生成器直接得到的，随机数一般是根据系统噪音产生。</p><hr><h3 id="私钥的存储"><a href="#私钥的存储" class="headerlink" title="私钥的存储"></a>私钥的存储</h3><p>以太坊在对私钥存储时使用了Web3 Secret Storage 技术。</p><p>用户设置密码，使用AES加密算法，将账户的私钥加密之后存储在本地的文件中。</p><p>具体过程为:</p><blockquote><ol><li>输入用户设置的密码，初始化Scrypt算法的参数。</li><li>加盐后,由Scrypt算法得到32字节长的数组，分为两组，前后各为16字节。</li><li>将前16字节数组，作为AES128算法的加密密钥。</li><li>设置AES算法的初始化数组，并使用密钥将用户的私钥加密得到密文。</li><li>将密文与后16字节数组通过Keccak256算法得到哈希值作为mac。</li><li>把Scrypt参数，盐，密文，AES的初始化数组和mac保存为加密文件。</li></ol></blockquote><p>流程图如下:<br><img src="http://wx3.sinaimg.cn/mw690/844f0132gy1furoubmstgj20vl0i7q4h.jpg" alt="Alt text"></p><p>最终得到通过JSON编码的密文文件。包含了加密过程中所使用的参数和用户私钥的密文。用户设置的密码不保存。</p><p>JSON格式的文件 :</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> &#123;<span class="attr">"address"</span>:<span class="string">"41741263be649ba40782037c8059c3efa6c658e0"</span>,</span><br><span class="line">  <span class="attr">"crypto"</span>:&#123;</span><br><span class="line">  <span class="attr">"cipher"</span>:<span class="string">"aes-128-ctr"</span>,</span><br><span class="line">  <span class="attr">"ciphertext"</span>:<span class="string">"44951b556a04873f2e4d8e72e9260adbe32934dd7a58883115b3fd733c0b7fba"</span>,</span><br><span class="line">  <span class="attr">"cipherparams"</span>:&#123;</span><br><span class="line">  <span class="attr">"iv"</span>:<span class="string">"36608c5ff76486a90f60ea96b81ecf67"</span></span><br><span class="line">  &#125;,</span><br><span class="line">      <span class="attr">"kdf"</span>:<span class="string">"scrypt"</span>,</span><br><span class="line">  <span class="attr">"kdfparams"</span>:&#123;</span><br><span class="line"> <span class="attr">"dklen"</span>:<span class="number">32</span>,</span><br><span class="line"> <span class="attr">"n"</span>:<span class="number">4096</span>,</span><br><span class="line"> <span class="attr">"p"</span>:<span class="number">6</span>,</span><br><span class="line"> <span class="attr">"r"</span>:<span class="number">8</span>,</span><br><span class="line">     <span class="attr">"salt"</span>:<span class="string">"a407ef6f4ba8a2a1c4c9ec80b49efa51d1887a2606853b84dbb72941d050609f"</span></span><br><span class="line">&#125;,</span><br><span class="line">   <span class="attr">"mac"</span>:<span class="string">"1f0a6a3acc2b7dc6621ade4f85cd4dc2690f3c269ac043ce13663279b85ada4f"</span></span><br><span class="line">&#125;,</span><br><span class="line">  <span class="attr">"id"</span>:<span class="string">"49220171-140c-45ea-82e2-96567e50fa5b"</span>,</span><br><span class="line">  <span class="attr">"version"</span>:<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="私钥文件的读取"><a href="#私钥文件的读取" class="headerlink" title="私钥文件的读取"></a>私钥文件的读取</h3><p>当用户对交易进行签名时，需要使用账户的私钥。此时钱包通过用户输入的密码，由AES算法将本地密钥文件中的密文解密得到账户的私钥。</p><p>整个过程类似对私钥加密存储时的逆过程。由于AES是对称加密算法，所以加密时的密钥同样可以用来解密。</p><p>从本地私钥文件读取用户私钥的过程为:</p><blockquote><ol><li>用户输入密码，解析密文文件得到Scrypt算法参数。</li><li>由Scrypt得到32字节数组，分为两组，前后各为16字节。</li><li>解析密钥文件得到密文，将后16字节与密文通过Keccak256算法得到哈希值。</li><li>将得到的哈希值与密钥文件中的mac进行比较若不同则告知用户密码错误。</li><li>验证密码的正确性之后，将前16字节数组作为AES算法的密钥。</li><li>对密文进行解密，得到明文即用户的私钥。</li></ol></blockquote><p>流程图如下:<br><img src="http://wx2.sinaimg.cn/mw690/844f0132gy1furouc4k1uj20vj0jnjtc.jpg" alt="Alt text"></p><hr><h2 id="确定性钱包"><a href="#确定性钱包" class="headerlink" title="确定性钱包"></a>确定性钱包</h2><p>确定性钱包也叫种子钱包，它通过种子管理私钥，当需要新的账户时，种子通过扩展秘钥算法，生成子秘钥，从而得到对应的账户。</p><p>生成账户的密钥都可以由种子导出，因此备份钱包时，只需要将种子备份，就可以恢复所有的密钥，从而得到钱包中所有账户。</p><p>确定性钱包的优点在于，方便用户对钱包的备份及转移，同时在理论上为用户提供了足够多的账户。然而由于密钥通过种子得到，因此种子的泄露就会导致所有账户的信息泄露。</p><h3 id="助记码"><a href="#助记码" class="headerlink" title="助记码"></a>助记码</h3><p>在确定性钱包的使用过程中，首先要生成一组随机数，助记码的作用是将随机数转换为一组人类可读的字符。</p><p>BIP-39协议中规定了助记码的产生过程。助记码使得转移以及备份钱包的随机数易于记录和描述。</p><p>助记码的生成流程:</p><blockquote><ol><li>输入有效的随机数数组，数组长度在128比特与256比特之间且能被32整除。</li><li>使用SHA256算法计算随机数的哈希值。</li><li>计算校验码长度N，为随机数数组长度除以32比特。</li><li>将哈希值的前N比特作为校验码加到随机数之后得到新的数组。</li><li>将数组分组，每组11比特，对应字符表得到助记码。</li></ol></blockquote><p><img src="http://wx4.sinaimg.cn/mw690/844f0132gy1furoilphkjj20ij0ivjsd.jpg" alt="Alt text"></p><p>助记码与随机数的生成没有直接关系，而且对应的字符表也是任意的。助记码能更好的记录和描述生成的随机数。</p><p>注意到，校验码也转换成了助记码中的一部分，这样助记码的完整性也可以得到验证。</p><hr><h3 id="由种子得到密钥"><a href="#由种子得到密钥" class="headerlink" title="由种子得到密钥"></a>由种子得到密钥</h3><p>助记码表示了一组随机数，通过PBKDF2算法得到种子，进而种子通过哈希算法的到钱包的主密钥。</p><p>BIP-39协议中也规定了由助记码(随机数)生成种子的过程。</p><p>由种子得到密钥的过程为:</p><blockquote><ol><li>将助记码由对应的字符表转换为数组。</li><li>字符”mnemonic+用户输入的密码“作为PBKFD2算法的盐。</li><li>将盐和数组通过SHA512算法经过2048轮运算得到512比特种子。</li></ol></blockquote><p><img src="http://wx1.sinaimg.cn/mw690/844f0132gy1furoim1bdtj20i80frmxk.jpg" alt="Alt text"></p><blockquote><ol start="4"><li>种子通过SHA512哈希算法得到512比特哈希值。</li><li>将哈希值分组，每组256比特。</li><li>前256比特作为用户的主私钥，再通过椭圆曲线算法得到对应的主公钥。</li><li>后256比特作为链码用来生成子密钥。</li></ol></blockquote><p><img src="http://wx2.sinaimg.cn/mw690/844f0132gy1furoimku2hj20o90gbjs3.jpg" alt="Alt text"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMaster</span><span class="params">(seed []<span class="keyword">byte</span>, net *chaincfg.Params)</span> <span class="params">(*ExtendedKey, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 验证种子有效性.</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(seed) &lt; MinSeedBytes || <span class="built_in">len</span>(seed) &gt; MaxSeedBytes &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ErrInvalidSeedLen</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用hamc-sha512算法计算秘钥</span></span><br><span class="line">hmac512 := hmac.New(sha512.New, masterKey)</span><br><span class="line">hmac512.Write(seed)</span><br><span class="line">lr := hmac512.Sum(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">secretKey := lr[:<span class="built_in">len</span>(lr)/<span class="number">2</span>]</span><br><span class="line">chainCode := lr[<span class="built_in">len</span>(lr)/<span class="number">2</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证产生的秘钥的有效性.</span></span><br><span class="line">secretKeyNum := <span class="built_in">new</span>(big.Int).SetBytes(secretKey)</span><br><span class="line"><span class="keyword">if</span> secretKeyNum.Cmp(btcec.S256().N) &gt;= <span class="number">0</span> || secretKeyNum.Sign() == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ErrUnusableSeed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">parentFP := []<span class="keyword">byte</span>&#123;<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>&#125;</span><br><span class="line"><span class="keyword">return</span> NewExtendedKey(net.HDPrivateKeyID[:], secretKey, chainCode,</span><br><span class="line">parentFP, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="扩展密钥"><a href="#扩展密钥" class="headerlink" title="扩展密钥"></a>扩展密钥</h3><p>确定性钱包中，主密钥通过密钥导出算法得到子扩展密钥。</p><p>扩展密钥是由父密钥，通过密钥导出算法，得到的包含链码等信息的子秘钥。</p><p>扩展密钥包含4部分信息: 1字节的密钥树深度，4字节的密钥指纹，4字节的子序号，以及32字节的链码和33字节的密钥。</p><p>私钥有前缀0x00,而扩展公钥为压缩形式，有前缀0x03或0x04，因此它们都为33字节。</p><p>由父扩展密钥，子序号和链码，可以计算得到相应的子扩展密钥。计算的方法在BIP-32协议中有具体的规定。</p><p>子序号最大为$2^{32}$,协议中规定当序号大于$2^{31}$时，用$N’$表示$2^{31}+N$。这样的目的是，区分由两种不同的密钥导出算法得到的子密钥。</p><p>两种密钥导出算法:</p><p>硬导出(Harden Derivation)</p><blockquote><ol><li>输入父私钥，链码，指定的子序号$m’$(&gt;$2^{31}$)</li><li>过HMAC-SHA512算法得到512比特哈希值。</li><li>将512比特哈希值分为两组，每组256比特</li><li>前256比特与父私钥相加然后模椭圆曲线的阶N得到子私钥。</li><li>子私钥通过椭圆曲线算法计算得到子公钥。</li><li>后256比特作为链码。 </li></ol></blockquote><p><img src="http://wx3.sinaimg.cn/mw690/844f0132gy1furoin0bnkj20sw0hxjsu.jpg" alt="Alt text"></p><p>公共导出(Public Derivation)</p><blockquote><ol><li>输入父私钥，链码，指定的子序号$m$(&lt;2^{31})</li><li>由父私钥计算得到父公钥(压缩公钥)为33字节。</li><li>将父公钥，链码，子序号通过HMAC-SHA512算法得到512比特哈希值。</li><li>将512比特哈希值分为两组，每组256比特。</li><li>前256比特与父私钥相加然后模椭圆曲线的阶N得到子私钥。</li><li>子私钥通过椭圆曲线算法计算得到子公钥。</li><li>后256比特作为链码。 </li></ol></blockquote><p><img src="http://wx4.sinaimg.cn/mw690/844f0132gy1furoind87vj20tf0i975t.jpg" alt="Alt text"></p><p>硬导出算法确保了子密钥的泄露不会导致主密钥泄露，而公共导出则在某一层父密钥泄露的情况下，会导致所有的密钥泄露，但是它的子密钥是由父公钥扩展得到，使得这种算法的应用场景更多。</p><p>通常钱包中结合使用了这两种密钥导出算法。</p><hr><h3 id="密钥路径"><a href="#密钥路径" class="headerlink" title="密钥路径"></a>密钥路径</h3><p>确定性钱包中，密钥都是通过主密钥由密钥导出算法得到，因此只需要输入对应的密钥路径，即可以通过密钥导出算法恢复出账户地址及对应的私钥。</p><p>BIP-44协议中规定了密钥导出路径，一般格式为: m / purpose’ / coin_type’ / account’ / change / address_index</p><p>puporse‘: 表示协议类型, 一般为44’即数字 $2^{31} + 44$。<br>coin_type: 表示数字货币类型，以太币类型为 66’即数字$2^{31} + 44$。<br>account’:从这一层级开始由主密钥导出子秘钥，第一层级使用硬导出，即子序号大于$2^{31}$,第一个账户为$0’$。<br>change : 以太坊钱包不需要这一层路径。<br>address_index : 第二层子密钥，使用公共导出，得到扩展公钥作为账户地址。</p><p><img src="http://wx4.sinaimg.cn/mw690/844f0132gy1furoinuuzqj20pt0ha75z.jpg" alt="Alt text"></p><p>例如: m/44’/60’/0’/0 表示根据Bip-44协议的路径，生成的以太币的第一个硬私钥的第一个账户地址。</p><p>这样，通过密钥路径，钱包由种子实现了对账户的管理，同时由路径可以恢复出私钥，实现了对交易的签名。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;钱包的类型&quot;&gt;&lt;a href=&quot;#钱包的类型&quot; class=&quot;headerlink&quot; title=&quot;钱包的类型&quot;&gt;&lt;/a&gt;钱包的类型&lt;/h2&gt;&lt;p&gt;用户通过钱包来管理账户，账户中包含了账户地址和账户的私钥信息。地址可以接收交易，而私钥在账户发起交易时对交易进行签名
      
    
    </summary>
    
      <category term="以太坊" scheme="http://ldlovezyh.cn/categories/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
    
      <category term="以太坊" scheme="http://ldlovezyh.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
      <category term="GO" scheme="http://ldlovezyh.cn/tags/GO/"/>
    
  </entry>
  
  <entry>
    <title>以太坊Account源代码阅读</title>
    <link href="http://ldlovezyh.cn/2018/07/23/Account%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>http://ldlovezyh.cn/2018/07/23/Account源码阅读/</id>
    <published>2018-07-22T16:00:00.000Z</published>
    <updated>2019-03-06T09:41:54.002Z</updated>
    
    <content type="html"><![CDATA[<p><code>account.go</code>包中实现了账户更高层次的管理，其中包含了两个重要的结构体，同时也有许多重要的概念值得去揣摩。</p><hr><h2 id="Account主体结构"><a href="#Account主体结构" class="headerlink" title="Account主体结构"></a>Account主体结构</h2><p>首先，定义了账户的概念，正如前面提到的账户地址由椭圆曲线加密算法产生的公钥得到的，账户中第一个成员就是账户地址。然后，对账户地址的位置用一个URL变量进行了定义，如果是在网络上则是一个网址，如果在本地就是本地路径。这样一个账户，通过直接定位和相对定位的两种方式我们能快速得到。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Account <span class="keyword">struct</span> &#123;</span><br><span class="line">        Address common.Address <span class="string">`json:"address"`</span>   <span class="comment">// Ethereum account address derived from the key</span></span><br><span class="line">        URL    URL         <span class="string">`json:"url"`</span>     <span class="comment">// Optional resource locator within a backend</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>如果说账户就是我们的银行卡的话那么我们就需要一个钱包，来保管这些卡片，因此<code>account.go</code>包中又定义了一个<code>Wallet</code>接口来实现了的账户管理的一些方法。这里需要注意，由一个seed可以得到多个账户，就像同样的银行可以开户多张银行卡一样。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Wallet <span class="keyword">interface</span>&#123;</span><br><span class="line">            URL() URL  <span class="comment">//钱包的位置，同样也用来对钱包进行管理</span></span><br><span class="line">            Status() &#123;<span class="keyword">string</span>, error&#125; <span class="comment">//当前钱包的状态，告知用户unlocked与否。</span></span><br><span class="line">            Open(passphrase <span class="keyword">string</span>) <span class="comment">// 通过账户的口令取得钱包的私钥</span></span><br><span class="line">            Close() error<span class="comment">//关闭</span></span><br><span class="line">            Accounts() []Account</span><br><span class="line">            Contains(account Account) <span class="keyword">bool</span></span><br><span class="line">            Derive(path DerivationPath, pin <span class="keyword">bool</span>)(Account, error)</span><br><span class="line">            SelfDerive(base DerivationPath, chain ethereum.ChainStateReader)</span><br><span class="line">            SignHash(account Account, hash []<span class="keyword">byte</span>)([]<span class="keyword">byte</span>,error)</span><br><span class="line">            SignTx(account Account, tx *types.Transaction, chainID *big.Int)(*<span class="keyword">type</span>.Transaction, error)</span><br><span class="line">            SignHashWithPassphrase(account Account, passphrase <span class="keyword">string</span>, hash []<span class="keyword">byte</span>)([]<span class="keyword">byte</span>, error)</span><br><span class="line">            SignTxWithPassphrase(account Account, passphrase <span class="keyword">string</span>, tx *types.Transaction，chainID *big.Int)(*types.Transaction, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到Wallet这个接口中定义了很多与账户有关的操作具体来说就是账户中保存了私钥的信息，当操作需要用到私钥时比如对交易的签名。同时也提供了简单的判断账户状态的一些方法。</p><p>同样的为了管理钱包，又定义了一个名为<code>backend</code>的接口，提供了对与钱包的操作的方法，首先可以返回所有存在的钱包的列表并且是根据URL字典序进行排序的，此外另一个订阅函数则向跟高层级的<code>manager</code>更新当前<code>backend</code>的状态，对钱包的移除，打开，增添都有不同的标记。</p><p><code>WalletEvent</code>结构体进行的定义:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Backend <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Wallets retrieves the list of wallets the backend is currently aware of.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The returned wallets are not opened by default. For software HD wallets this</span></span><br><span class="line"><span class="comment">// means that no base seeds are decrypted, and for hardware wallets that no actual</span></span><br><span class="line"><span class="comment">// connection is established.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The resulting wallet list will be sorted alphabetically based on its internal</span></span><br><span class="line"><span class="comment">// URL assigned by the backend. Since wallets (especially hardware) may come and</span></span><br><span class="line"><span class="comment">// go, the same wallet might appear at a different positions in the list during</span></span><br><span class="line"><span class="comment">// subsequent retrievals.</span></span><br><span class="line">Wallets() []Wallet</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subscribe creates an async subscription to receive notifications when the</span></span><br><span class="line"><span class="comment">// backend detects the arrival or departure of a wallet.</span></span><br><span class="line">Subscribe(sink <span class="keyword">chan</span>&lt;- WalletEvent) event.Subscription</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚刚我们提到了<code>backend</code>虽然提供了对钱包列表的管理函数，但它依然要将状态的更新提交到更高层的管理结构<code>manager</code>中。</p><p>下面我们来看看<code>manager</code>结构体的定义，如果说钱包可以装很多银行卡那么<code>manager</code>可以理解为我们存钱的银行它要对所有已经存在的钱包状态可以及时的知晓，它是通过<code>backend</code>所提交的事件类型来间接管理钱包，<code>manager</code>中的方法<code>func (am *Manager) update()</code>就是通过监听<code>backend</code>的事件类型来更新钱包缓存。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Manager <span class="keyword">struct</span> &#123;</span><br><span class="line">backends <span class="keyword">map</span>[reflect.Type][]Backend <span class="comment">// Index of backends currently registered</span></span><br><span class="line">updaters []event.Subscription       <span class="comment">// Wallet update subscriptions for all backends</span></span><br><span class="line">updates  <span class="keyword">chan</span> WalletEvent           <span class="comment">// Subscription sink for backend wallet changes</span></span><br><span class="line">wallets  []Wallet                   <span class="comment">// Cache of all wallets from all registered backends</span></span><br><span class="line"></span><br><span class="line">feed event.Feed <span class="comment">// Wallet feed notifying of arrivals/departures</span></span><br><span class="line"></span><br><span class="line">quit <span class="keyword">chan</span> <span class="keyword">chan</span> error</span><br><span class="line">lock sync.RWMutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到账户的管理也是三个层次的管理:account=&gt;wallet=&gt;backend=&gt;manager，层次以及各自的作用还是比较清晰的。账户的地址以及密钥的生成我们已经十分熟悉了接下来我们重点看一下钱包是如何有效管理密钥的。</p><hr><h2 id="钱包中对账户的管理"><a href="#钱包中对账户的管理" class="headerlink" title="钱包中对账户的管理"></a>钱包中对账户的管理</h2><p>正如前面所说钱包实际上是有实现对私钥的管理，接口中的<code>open()</code>和<code>close()</code>函数就完成了对账户私钥的存取，进而实现对交易的签名等一系列操作。以太坊中私钥的存储有两种方式，分别对应着传统的<strong>随机钱包</strong>(Nondeterministic (Random) Wallets),即钱包中存储了所有由椭圆曲线算法产生的密钥，另一种则是<strong>HD</strong>(Deterministic (Seeded) Wallets)钱包，钱包中的所有密钥的管理实际上是有一个种子密钥生成，这里我们先看一下Nondeterministic Wallets。</p><p>以太坊中<code>keystore/keystore_wallet.go</code>实现了上面提到的wallet接口，采用的传统的密钥存储方式。每一个密钥由它的加密存储的参数，最终组织成了一个json文件，下图就是一个json格式存储的key:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"address"</span>: <span class="string">"001d3f1ef827552ae1114027bd3ecf1f086ba0f9"</span>,</span><br><span class="line">    <span class="comment">//AES加密函数</span></span><br><span class="line">    <span class="string">"crypto"</span>: &#123;</span><br><span class="line">        <span class="string">"cipher"</span>: <span class="string">"aes-128-ctr"</span>,</span><br><span class="line">        <span class="string">"ciphertext"</span>: <span class="string">"233a9f4d236ed0c13394b504b6da5df02587c8bf1ad8946f6f2b58f055507ece"</span>,</span><br><span class="line">        <span class="string">"cipherparams"</span>: &#123;</span><br><span class="line">            <span class="string">"iv"</span>: <span class="string">"d10c6ec5bae81b6cb9144de81037fa15"</span></span><br><span class="line">        &#125;,</span><br><span class="line">  <span class="comment">//密钥导出函数的参数 </span></span><br><span class="line">        <span class="string">"kdf"</span>: <span class="string">"scrypt"</span>,</span><br><span class="line">        <span class="string">"kdfparams"</span>: &#123;</span><br><span class="line">            <span class="string">"dklen"</span>: <span class="number">32</span>,</span><br><span class="line">            <span class="string">"n"</span>: <span class="number">262144</span>,</span><br><span class="line">            <span class="string">"p"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="string">"r"</span>: <span class="number">8</span>,</span><br><span class="line">            <span class="string">"salt"</span>: <span class="string">"99d37a47c7c9429c66976f643f386a61b78b97f3246adca89abe4245d2788407"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"mac"</span>: <span class="string">"594c8df1c8ee0ded8255a50caf07e8c12061fd859f4b7c76ab704b17c957e842"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"id"</span>: <span class="string">"4fcb2ba4-ccdb-424f-89d5-26cce304bf9c"</span>,</span><br><span class="line">    <span class="string">"version"</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于在对交易进行签名时需要用到私钥，因此<code>keystore_wallet</code>中包含的对签名的操作的方法，则涉及到了key的读取:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *keystoreWallet)</span> <span class="title">SignTxWithPassphrase</span><span class="params">(account accounts.Account, passphrase <span class="keyword">string</span>, tx *types.Transaction, chainID *big.Int)</span> <span class="params">(*types.Transaction, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// Make sure the requested account is contained within</span></span><br><span class="line"><span class="keyword">if</span> account.Address != w.account.Address &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, accounts.ErrUnknownAccount</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> account.URL != (accounts.URL&#123;&#125;) &amp;&amp; account.URL != w.account.URL &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, accounts.ErrUnknownAccount</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Account seems valid, request the keystore to sign</span></span><br><span class="line"><span class="keyword">return</span> w.keystore.SignTxWithPassphrase(account, passphrase, tx, chainID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到签名最终调用的是一个<code>keystore</code>结构体中定义的签名方法，以太坊中单独定义了一个keystore包，用来管理存储在客户端的密钥文件，包括与钱包相关的更新操作，与交易相关的签名操作，以及对密钥文件的读取。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> KeyStore <span class="keyword">struct</span> &#123;</span><br><span class="line">storage  keyStore                     <span class="comment">// Storage backend, might be cleartext or encrypted</span></span><br><span class="line">cache    *accountCache                <span class="comment">// In-memory account cache over the filesystem storage</span></span><br><span class="line">changes  <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;                <span class="comment">// Channel receiving change notifications from the cache</span></span><br><span class="line">unlocked <span class="keyword">map</span>[common.Address]*unlocked <span class="comment">// Currently unlocked account (decrypted private keys)</span></span><br><span class="line"></span><br><span class="line">wallets     []accounts.Wallet       <span class="comment">// Wallet wrappers around the individual key files</span></span><br><span class="line">updateFeed  event.Feed              <span class="comment">// Event feed to notify wallet additions/removals</span></span><br><span class="line">updateScope event.SubscriptionScope <span class="comment">// Subscription scope tracking current live listeners</span></span><br><span class="line">updating    <span class="keyword">bool</span>                    <span class="comment">// Whether the event notification loop is running</span></span><br><span class="line"></span><br><span class="line">mu sync.RWMutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点来看一下，与密钥存储有关的成员<code>storage</code>，<code>storage</code>的初始化分为两种情况:</p><div class="note info"><p>1.密钥直接明文存储：<code>ks := &amp;KeyStore{storage: &amp;keyStorePlain{keydir}}</code><br>2.密钥加密后存储：<code>ks := &amp;KeyStore{storage: &amp;keyStorePassphrase{keydir, scryptN, scryptP}}</code></p></div><p>其中加密的存储方式则是继承<code>keyStorePassphrase</code>结构体，将密钥加密之后编组为json格式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EncryptKey</span><span class="params">(key *Key, auth <span class="keyword">string</span>, scryptN, scryptP <span class="keyword">int</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">authArray := []<span class="keyword">byte</span>(auth)</span><br><span class="line">salt := randentropy.GetEntropyCSPRNG(<span class="number">32</span>)</span><br><span class="line">derivedKey, err := scrypt.Key(authArray, salt, scryptN, scryptR, scryptP, scryptDKLen)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">encryptKey := derivedKey[:<span class="number">16</span>]</span><br><span class="line">keyBytes := math.PaddedBigBytes(key.PrivateKey.D, <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">iv := randentropy.GetEntropyCSPRNG(aes.BlockSize) <span class="comment">// 16</span></span><br><span class="line">cipherText, err := aesCTRXOR(encryptKey, keyBytes, iv)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">mac := crypto.Keccak256(derivedKey[<span class="number">16</span>:<span class="number">32</span>], cipherText)</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是由用户口令加密椭圆曲线生成的私钥：</p><div class="note info"><p>1.输入用户口令，密钥导出函数的参数。<br>2.用户口令加盐由密钥导出函数得到32字节数组前16字节作为AES加密密钥。<br>3.输入明文，初始数组，私钥使用AES加密得到密文<br>4.将生成的的导出密钥的16-32字节作为mac</p></div><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;account.go&lt;/code&gt;包中实现了账户更高层次的管理，其中包含了两个重要的结构体，同时也有许多重要的概念值得去揣摩。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;Account主体结构&quot;&gt;&lt;a href=&quot;#Account主体结构&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="以太坊" scheme="http://ldlovezyh.cn/categories/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
    
      <category term="以太坊" scheme="http://ldlovezyh.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
      <category term="GO" scheme="http://ldlovezyh.cn/tags/GO/"/>
    
  </entry>
  
  <entry>
    <title>以太坊账户地址与交易签名</title>
    <link href="http://ldlovezyh.cn/2018/07/22/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%B4%A6%E6%88%B7%E5%9C%B0%E5%9D%80%E4%B8%8E%E4%BA%A4%E6%98%93%E7%AD%BE%E5%90%8D/"/>
    <id>http://ldlovezyh.cn/2018/07/22/以太坊账户地址与交易签名/</id>
    <published>2018-07-21T16:00:00.000Z</published>
    <updated>2019-03-06T09:43:32.961Z</updated>
    
    <content type="html"><![CDATA[<h1 id="以太坊账户地址"><a href="#以太坊账户地址" class="headerlink" title="以太坊账户地址"></a>以太坊账户地址</h1><p>以太坊有两种不同的账户类型:</p><div class="note info"><ol><li>合约账户。</li><li>外部账户EOA(Externally Owned Accounts)。</li></ol></div><p>合约账户对应1个智能合约的部署地址，该地址可以接受代币的转入，但是代币的转出则需要在合约中提供接口函数。</p><p>外部账户的所有权是由密钥来验证的。密钥由用户存储在文件或钱包中。</p><p>钱包中的密钥完全独立于以太坊协议，可由用户的钱包软件生成和管理而并不需要依照区块链或接入互联网。</p><p>账户中的密钥包含两部分：公钥和私钥,公钥可以暴露给其他人，而私钥只有账户的所有者才能管理，掌握了私钥就掌握了该账户的所有权，所以需要对私钥进行可靠的保密存储。</p><p>以太坊的交易支付中，接收方由一个以太坊地址表示，地址由账户的公钥生成。以太坊地址是用户能接触到的密钥的唯一表示。</p><hr><h2 id="椭圆曲线加密"><a href="#椭圆曲线加密" class="headerlink" title="椭圆曲线加密"></a>椭圆曲线加密</h2><p>公钥加密方案基于困难的数学难题，如著名的RSA加密算法是基于大整数的分解难题。</p><p>以太坊中使用的是椭圆曲线加密方案，它基于椭圆曲线上的离散对数问题,是一种公钥加密方案。</p><p>椭圆曲线上的所有点对加法作成一个循环群，在曲线上进行数乘运算是简单的，但它的逆运算则是困难的。</p><p>以太坊中选取椭圆曲线和比特币中的一样为secp256k1，实际上以太坊中调用的就是比特币的椭圆曲线加密库。</p><hr><h3 id="加密算法-ECDH"><a href="#加密算法-ECDH" class="headerlink" title="加密算法(ECDH)"></a>加密算法(ECDH)</h3><p>以太坊账户的私钥，由随机数生成器得到的256bit的随机数，随机算法是基于系统噪音设计的。</p><p>公钥是由椭圆曲线算法由私钥计算得到。但是由公钥是无法计算得到私钥，因此可用来作为账户地址。公钥数值上满足椭圆曲线方程，为512比特。</p><p>椭圆曲线密码加解密步骤：</p><div class="note info"><ol><li>私钥256比特随机数:：$sk\leftarrow [1,n-1]$。</li><li>公钥由私钥得到：$pk=sk*G$,$G$是椭圆曲线的基点。</li><li>加密步骤：选取随机数$r\leftarrow [1,n-1]$，设明文为$M$  由公钥得到密文$C_x=r\times G,C_y=M+r\times PK$密文为 $C=(C_x,C_y)$</li><li>解密步骤：密文由私钥解密：$M=C_y - sk\times C_x$</li></ol></div><hr><h3 id="数字签名算法-ECDSA"><a href="#数字签名算法-ECDSA" class="headerlink" title="数字签名算法(ECDSA)"></a>数字签名算法(ECDSA)</h3><p>以太坊中使用椭圆曲线数字签名算法(Elliptic Curve Digital Signature Algorithm,ECDSA),它有三个目的：</p><div class="note info"><ol><li>签名证明了私钥的持有者为帐户的所有者，表明以太币支出，或合约的执行是经过授权的。</li><li>证明了授权是不可抵赖的。</li><li>防止交易数据在交易完成后被篡改。</li></ol></div><p>数字签名的数学方案有两部分组成，分为签名部分，和签名的验证部分。</p><p>签名的过程：</p><div class="note info"><ol><li>设私钥为$sk$，公钥$PK=sk\times G$,$G$为椭圆曲线的基点，椭圆曲线的阶为$n$。</li><li>计算消息m的hash值$e=HASH(m)$,以太坊中哈希算法为Keacck256。</li><li>选取随机数$k\leftarrow[1,n-1]$，计算$M = k\times G$。</li><li>计算 $r=M_x\bmod n$,若$r=0$返回第三步</li><li>计算 $s=k^{-1}\times (z+r\times sk)\bmod n$,若$s=0$返回第三步。</li><li>$(r,s)$即为所得签名。</li></ol></div><p>签名的验证过程：</p><p>验证算法为签名算法的逆过程，若得到的结果满足椭圆曲线方程则验证通过。</p><div class="note info"><ol><li>验证签名(r,s)的有效性，计算得到消息的hash值$e=HASH(m)$。</li><li>计算参数：$w=s^{-1}\bmod n$。</li><li>计算$Q=e\times s^{-1}+r\times s^{-1}\times PK$若结果满足椭圆曲线方程验证成功。</li><li>$r=Q_x$则签名有效。</li></ol></div><hr><h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>哈希函数的输入称为预图像或者消息，输出被称为哈希值或摘要。</p><p>哈希算法依据分组密码的思路，将原消息压缩和混淆。从而将任意长度的字符串映射为固定长度的比特串。</p><p>密码学中哈希函数是一类单向函数，由输入很容易得到输出，但是由输出则很难得到输入的信息。</p><p>哈希函数有以下五种主要的性质：</p><div class="note info"><ol><li>确定性：相同的消息总是得到相同的哈希值</li><li>高效性：任意给定的消息，哈希算法可以快速得到其哈希值</li><li>不可逆：有限时间类，由哈希值计算得到原消息是不可能的</li><li>雪崩性：原消息微小的改动即会导值所得到的哈希值得巨大差异</li><li>低碰撞：两个不同的消息得到同样的哈希值得概率是非常低的</li></ol></div><p>这些性质使得哈希函数在以太坊中有着广泛的应用包括数据签名，消息完整性验证，工作量证明，随机数生成等等。</p><p>目前通用的哈希算法有四代标准，SHA1有名的MD5，SHA2的 SHA256，SHA512算法，及以太坊中使用的SHA3标准的Keacck256算法。</p><hr><h1 id="账户地址的生成"><a href="#账户地址的生成" class="headerlink" title="账户地址的生成"></a>账户地址的生成</h1><p>以太坊通过椭圆曲线加密算法来实现对交易的签名与验证，路径<code>github.com/ethereum/go-ethereum/crypto/</code>下的代码包负责所有与加密相关的操作。</p><p>以太坊中的地址是使用单向hash函数Keacck-256从公钥或合约中派生出来的唯一标识符。</p><p>具体过程为：</p><div class="note info"><ol><li>由椭圆曲线加密算法中得到64bytes字符串公钥。</li><li>使用Keacck-256算法计算公钥的哈希值为32bytes。</li><li>保留最后的20bytes(大端表示)作为以太坊的地址。</li></ol></div><hr><h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><p>GO语言包中<code>crypto/ecdsa</code>包含了关于椭圆曲线的结构体声明和操作的函数，以太坊也是通过调用它来生成账户的私钥并产生公钥的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PublicKey <span class="keyword">struct</span> &#123;</span><br><span class="line">    elliptic.Curve</span><br><span class="line">    X, Y *big.Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PrivateKey <span class="keyword">struct</span> &#123;</span><br><span class="line">    PublicKey</span><br><span class="line">D *big.Int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公钥<code>PublicKey</code>结构体,包含一个<code>elliptic.Curve</code>接口的实现体来提供椭圆曲线的所有属性和相关操作；公钥的成员<code>X,Y</code>即为生成的未压缩公钥。</p><p>私钥是以太坊账户中存储的唯一可以用来验证账户身份的信息，组合体<code>PrivateKey</code>有成员<code>PublicKey</code>，成员<code>D</code>是算法生成的私钥。</p><p>根据不同的用途可以使用结构体<code>PrivateKey</code>或成员<code>PrivateKey.D</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateKey</span><span class="params">(c elliptic.Curve, rand io.Reader)</span> <span class="params">(*PrivateKey, error)</span></span></span><br></pre></td></tr></table></figure><p>密钥的生成是通过方法<code>GenerateKey()</code>,它返回私钥<code>PrivateKey</code>，私钥中包含成员<code>PublicKey</code>，可以生成账户地址。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ToECDSAPub</span><span class="params">(pub []<span class="keyword">byte</span>)</span> *<span class="title">ecdsa</span>.<span class="title">PublicKey</span></span> &#123;  </span><br><span class="line">    x, y := elliptic.Unmarshall(S256(), pub)  </span><br><span class="line">    <span class="keyword">return</span> &amp;ecdsa.PublicKey&#123;Curve:S256(), X:x, Y:y&#125;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FromECDSAPub</span><span class="params">(pub *ecdsa.PublicKey)</span> []<span class="title">byte</span></span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> elliptic.Marshall(S256(), pub.X, pub.Y)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在生成地址之前，将结构体<code>ecdsa.PublicKey{}</code>转换为字符串类型的公钥。在<code>github.com/ethereum/go-ethereum/crypto/crypto.go</code>中定义了相关的转换函数<code>ToECDSAPub()</code>和<code>FromECDSAPub</code>。</p><p>这两个函数完成了big.int 类型到 []byte的转换，实际调用时注意返回的<code>[]byte</code>类型字符串是由三部分组成，第一部分为曲线参数，后两部分是公钥字面值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (  </span><br><span class="line">    HashLength = <span class="number">32</span>  </span><br><span class="line">    AddressLength = <span class="number">20</span>  </span><br><span class="line">)  </span><br><span class="line"><span class="keyword">type</span> Hash [HashLength]<span class="keyword">byte</span>  </span><br><span class="line"><span class="keyword">type</span> Address [AddressLength]<span class="keyword">byte</span></span><br></pre></td></tr></table></figure><p>以太坊在<code>github.com/ethereum/go-ethereum/common/types.go</code>中用两个自定义类型表示32bytes的hash值和20bytes的账户地址。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Keccak512</span><span class="params">(data ...[]<span class="keyword">byte</span>)</span> []<span class="title">byte</span> </span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Keccak256Hash</span><span class="params">(data ...[]<span class="keyword">byte</span>)</span> <span class="params">(h common.Hash)</span></span></span><br></pre></td></tr></table></figure><p>由哈希算法Keccak256计算公钥的哈希值,以太坊在<code>github.com/ethereum/go-ethereum/crypto/crypto.go</code>中通过<code>Keccak512()</code>和<code>Keccak256Hash()</code>方法实现。</p><p>需要注意函数中的参数是公钥的字符串，通过格式转换函数得到的公钥字符串中<code>pubkey[0]</code>并不是公钥，只需传入<code>pubkey[1:]</code>来计算公钥的hash值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BytesToAddress</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="title">Address</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a Address</span><br><span class="line">a.SetBytes(b)</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Address)</span> <span class="title">SetBytes</span><span class="params">(b []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(b) &gt; <span class="built_in">len</span>(a) &#123;</span><br><span class="line">b = b[<span class="built_in">len</span>(b)-AddressLength:]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">copy</span>(a[AddressLength-<span class="built_in">len</span>(b):], b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，将大端表示的公钥哈希值最后的20bytes作为账户地址，由<code>github.com/ethereum/go-ethereum/common</code>中<code>BytesToAddress()</code>和<code>SetBytes()</code>方法实现。</p><p>这两个函数实际上是用来验证字符串是否满足账户地址的格式。</p><hr><h1 id="交易的签名"><a href="#交易的签名" class="headerlink" title="交易的签名"></a>交易的签名</h1><p>以太坊中,交易在被放进区块时要经过椭圆曲线签名算法进行数字签名。</p><p>对交易数字签名主要包含两部分:</p><div class="note info"><ol><li>使用私钥（签名秘钥）从交易信息中创建签名 </li><li>允许任何人使用交易信息和公钥验证签名       </li></ol></div><p>以太坊中交易进行签名主要有以下步骤：</p><div class="note info"><ol><li>创建交易，完整的交易数据结构包含: nonce, gasPrice, startGas, to, value, data, v, r, s。</li><li>由RLP编码将交易序列化。</li><li>通过Keaccak256计算交易的哈希值。</li><li>由账户私钥对交易哈希值签名。</li></ol></div><p>$Sig=F_{sig}(F_{keccak256}(m),sk), Sig = (R,S)$</p><hr><h2 id="相关代码-1"><a href="#相关代码-1" class="headerlink" title="相关代码"></a>相关代码</h2><p>在<code>github.com/ethereum/go-ethereum/core/types</code>中定义了交易的结构体类型，并且提供了新建交易的函数<code>NewTransaction()</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Transaction <span class="keyword">struct</span> &#123;</span><br><span class="line">data txdata</span><br><span class="line"><span class="comment">// caches</span></span><br><span class="line">hash atomic.Value</span><br><span class="line">size atomic.Value</span><br><span class="line">from atomic.Value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> txdata <span class="keyword">struct</span> &#123;</span><br><span class="line">AccountNonce <span class="keyword">uint64</span>          </span><br><span class="line">Price        *big.Int        </span><br><span class="line">GasLimit     <span class="keyword">uint64</span>          </span><br><span class="line">Recipient    *common.Address </span><br><span class="line">Amount       *big.Int        </span><br><span class="line">Payload      []<span class="keyword">byte</span>         </span><br><span class="line"><span class="comment">// 签名值</span></span><br><span class="line">V *big.Int</span><br><span class="line">R *big.Int</span><br><span class="line">S *big.Int</span><br><span class="line">Hash *common.Hash</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTransaction</span><span class="params">(nonce <span class="keyword">uint64</span>, to common.Address, amount *big.Int, gasLimit <span class="keyword">uint64</span>, gasPrice *big.Int, data []<span class="keyword">byte</span>)</span> *<span class="title">Transaction</span></span></span><br></pre></td></tr></table></figure><p>完整的交易必须包含有转入方地址<code>Recipient</code>，转账金额<code>AccountNonce</code>，每个交易独立的<code>gasprice</code>和<code>gaslimit</code>，签名<code>V,R,S</code>初始为0。</p><p>以太坊在<code>github.com/ethereum/go-ethereum/rlp</code>设计了rlp编码的规则，定义了与rlp编码有关的函数。</p><p>在对交易序列化的过程中实际上是完成types.Transaction{}结构体到[]byte类型的转换。</p><p>由哈希算法Keccak256得到交易的哈希值后，调用椭圆曲线签名算法，进行签名。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sign</span><span class="params">(msg []<span class="keyword">byte</span>, seckey []<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以太坊对bitcoin的secp256k1 C库进行了封装，在<code>github.com/ethereum/go-ethereum/crypto/secp256k1</code>中定义了签名函数<code>Sign()</code>,需要传入私钥和被签名信息。</p><p>最后，由<code>*big.Int</code>类型成员<code>R，S，V</code>来存放64bytes签名。<code>R</code>和<code>S</code>分别存放32bytes，<br><code>V</code>1bytes使恢复公钥时加速运算。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SignTx</span><span class="params">(tx *Transaction, s Signer, prv *ecdsa.PrivateKey)</span> <span class="params">(*Transaction, error)</span></span> &#123;  </span><br><span class="line">    h := s.Hash(tx)  </span><br><span class="line">    sig, err := crypto.Sign(h[:], prv)  </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> tx.WithSignature(s, sig)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以太坊也在github.com/ethereum/go-ethereum/core/types/transaction_signing.go中定义了直接生成交易的数字签名的函数<code>SignTx()</code>函数。</p><hr><h1 id="交易签名的验证"><a href="#交易签名的验证" class="headerlink" title="交易签名的验证"></a>交易签名的验证</h1><p>签名的验证，证明只有生成该签名的私钥所有者才能在该交易上产生这个签名。</p><p>验证签名时，需要有签名<code>R</code>，<code>S</code>它们包含在交易之中。</p><p>签名验证主要步骤：</p><div class="note info"><ol><li>由交易的hash值和签名得到账户公钥。</li><li>使用公钥和签名通过椭圆曲线加密算法对交易进行验证。</li></ol></div><hr><h2 id="相关代码-2"><a href="#相关代码-2" class="headerlink" title="相关代码"></a>相关代码</h2><p>以太坊对bitcoin的secp256k1 C库进行了封装，在<code>github.com/ethereum/go-ethereum/crypto/secp256k1</code>,定义了恢复公钥的函数<code>RecoverPubkey（）</code>和验证签名的函数<code>VerifySignature（）</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RecoverPubkey</span><span class="params">(msg []<span class="keyword">byte</span>, sig []<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>VerifySignature()</code>用来验证对应公钥的签名，传入对应交易的签名<code>R，S</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">VerifySignature</span><span class="params">(pubkey, msg, signature []<span class="keyword">byte</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(msg) != <span class="number">32</span> || <span class="built_in">len</span>(signature) != <span class="number">64</span> || <span class="built_in">len</span>(pubkey) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">sigdata := (*C.uchar)(unsafe.Pointer(&amp;signature[<span class="number">0</span>]))</span><br><span class="line">msgdata := (*C.uchar)(unsafe.Pointer(&amp;msg[<span class="number">0</span>]))</span><br><span class="line">keydata := (*C.uchar)(unsafe.Pointer(&amp;pubkey[<span class="number">0</span>]))</span><br><span class="line"><span class="keyword">return</span> C.secp256k1_ext_ecdsa_verify(context, sigdata, msgdata, keydata, C.size_t(<span class="built_in">len</span>(pubkey))) != <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以太坊中也在<code>github.com/ethereum/go-ethereum/crypto</code>中定义了直接验证交易数字签名的函数<code>ValidateSignatureValues</code>，本质上是对上面的两个函数的封装。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValidateSignatureValues</span><span class="params">(v <span class="keyword">byte</span>, r, s *big.Int, homestead <span class="keyword">bool</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r.Cmp(common.Big1) &lt; <span class="number">0</span> || s.Cmp(common.Big1) &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> homestead &amp;&amp; s.Cmp(secp256k1halfN) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r.Cmp(secp256k1N) &lt; <span class="number">0</span> &amp;&amp; s.Cmp(secp256k1N) &lt; <span class="number">0</span> &amp;&amp; (v == <span class="number">0</span> || v == <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;以太坊账户地址&quot;&gt;&lt;a href=&quot;#以太坊账户地址&quot; class=&quot;headerlink&quot; title=&quot;以太坊账户地址&quot;&gt;&lt;/a&gt;以太坊账户地址&lt;/h1&gt;&lt;p&gt;以太坊有两种不同的账户类型:&lt;/p&gt;
&lt;div class=&quot;note info&quot;&gt;&lt;ol&gt;
&lt;li
      
    
    </summary>
    
      <category term="以太坊" scheme="http://ldlovezyh.cn/categories/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
    
      <category term="以太坊" scheme="http://ldlovezyh.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
      <category term="GO" scheme="http://ldlovezyh.cn/tags/GO/"/>
    
      <category term="椭圆曲线加密" scheme="http://ldlovezyh.cn/tags/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>椭圆曲线加密原理</title>
    <link href="http://ldlovezyh.cn/2018/07/15/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/"/>
    <id>http://ldlovezyh.cn/2018/07/15/椭圆曲线加密原理/</id>
    <published>2018-07-14T16:00:00.000Z</published>
    <updated>2019-03-06T09:42:48.943Z</updated>
    
    <content type="html"><![CDATA[<p>区块链中主要使用了公钥加密算法，具体为椭圆曲线加密及其算法。</p><p>经常看到的如<code>ECC</code>，<code>ECDH</code>，<code>ECDSA</code>，就是一系列与椭圆曲线有关的缩写。<code>ECC</code>为椭圆曲线密码(Elliptic Curve Cryptography)的缩写。其它两个意思为基于椭圆曲线的密码算法和签名算法。</p><p>此外其它的公钥密码方案也得到大量使用，如著名的 RSA密码，DSA 和DH(Diffie Hellman)密码。它们都是基于有限域上的模运算相关一些困难问题而设计出的。</p><p>并且注意到<code>DH</code>和上面的<code>ECDH</code>有两个相同的字母，实际上这两种算法是非常相似的。</p><p><code>DH</code>表示Diffie Hellman算法，它基于有限域上的离散对数问题设计，顾名思义<code>ECDH</code>可理解为椭圆曲线上的Diffie Hellman算法，即基于椭圆曲线上的离散对数问题设计的。</p><hr><h2 id="有限域和离散对数"><a href="#有限域和离散对数" class="headerlink" title="有限域和离散对数"></a>有限域和离散对数</h2><p>简单来说，有限域是一个由有限个元素组成的集合，例如将整数模一个素数$p$之后得到的集合，就可以得到一个有限域，通常记为$\mathbb{Z}_p$或者$\mathbb{F}_p$。如$\mathbb{F}_5= {0,1,2,3,4} $包含所有模5可能的结果。</p><p>容易看出,有限域$\mathbb{F}_p$包含所有$\bmod p$从0到$p-1$的整数。</p><p>有限域上定义了两种运算：称为加法(+)和乘法(*), 两种运算对于有限域中的元素来说都是封闭的且满足结合律和交换律。</p><p>对乘法有特殊的元素单位元即相当于整数中的1，这保证了乘法存在逆元从而使有限域中的元素做除法运算得到的结果还在有限域中，达到封闭的要求。如：$\mathbb{F}_5$中$2*3\bmod 5 =1$,则2的逆元为3，3依然是在有限域中。</p><p>显然所有的整数不作成一个有限域，因为任意一个整数的逆为一个分数。</p><p>对加法同样定义逆运算即减法，因此需要特殊的元素零元即0，保证封闭性。</p><p>以$\mathbb{F}_{5}$为例具体看一下这些运算：</p><div class="note default"><p>加法：$(1+2)\bmod5=3$<br>减法：$(1-2)\bmod5=4$<br>加法逆：因为$(2+(-2)) \bmod5=(2+3)\bmod5=0$所以$-2\bmod5=3$<br>乘法：$2\ast4\bmod5=3$<br>除法：$(2\div3)\bmod5=4$,除法运算开销很大实际上是通过先计算逆元再计算乘法得到的，$2\ast 3^{-1}\bmod5=2\ast 2\bmod5=4$<br>乘法逆：因为$2\ast2^{-1}\bmod5=2\ast3\bmod5=1$所以$2^{-1}\bmod5=3$</p></div><p>上面的例子可以看到，有限域上的运算最终都要模上素数$p$,而加法的逆元算和乘法的逆元算实际上是求解$(2-x)\bmod5=0$和$2\ast x \bmod 5=1$得到的。前者很容易计算，但计算后者就需要很大的开销。</p><p>对有限域要选取素数$p$来作为模数，因为乘法的逆运算要满足封闭性,若选取一个合数如$4$,则$2\ast x\bmod 4 = 1$是没有解的，那么自然不能满足封闭性的要求。</p><hr><h3 id="除法运算"><a href="#除法运算" class="headerlink" title="除法运算"></a>除法运算</h3><p>在密码设计中$p$通常是选取一个很大的素数$O(2^{256})$，那么有限域中除法计算的结果就不那么容易得到了。</p><p>例如，计算$2\div3\bmod 5$,可以转换成乘法计算$2\ast 3^{-1}\bmod 5$ ，即求解方程$3\ast x\bmod 5=1$。</p><p>通常使用<strong>扩展欧几里得算法</strong><a href="https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm" target="_blank" rel="noopener">(extended Eucilidean algorithm )</a>可以求得某个元素的的乘法逆元。Go语言代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//欧几里得算法求最大公因数,(x,y)和（x,xmody）的最大公约数相同</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcd</span><span class="params">(x,y <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> y!=<span class="number">0</span>&#123;</span><br><span class="line">x,y=y,x%y</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//扩展欧几里得算法，对于x,y必存在整数u，v使得gcd(x,y)=u*x+v*y</span></span><br><span class="line"><span class="comment">//档x,y互素时则返回的u即满足x*u mod y=1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">extendeGcd</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="params">(gcd, u, v <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">         u, old_u := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">         v, old_v := <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">         r, old_r := y, x</span><br><span class="line"> </span><br><span class="line">         <span class="keyword">for</span> r != <span class="number">0</span> &#123;</span><br><span class="line">                 quotient := <span class="keyword">int</span>(old_r / r)</span><br><span class="line">                 old_r, r = r, old_r-quotient*r</span><br><span class="line">                 old_u, u = u, old_u-quotient*u</span><br><span class="line">                 old_v, v = v, old_v-quotient*v</span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">         <span class="keyword">return</span> old_r, old_u, old_v</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="群和离散对数问题"><a href="#群和离散对数问题" class="headerlink" title="群和离散对数问题"></a>群和离散对数问题</h3><p>由有限域的定义，可以看到有限域最重要的特征是有限域上的元素对于其上定义的两种运算乘法和加法都是封闭的。</p><p>把去掉零元的有限域记为$\mathbb{F}^{\ast}_{p}$。以$\mathbb{F}^{\ast}_5={1,2,3,4}$为例，此时，对加法来说没有零元，那么集合中元素的加法就是不封闭的了，因为会出现$2+3\bmod5=0$而$0\notin\mathbb{F}^{\ast}_5$这种情况。</p><p>对于乘法，单位元1依然在集合里，因此元素的逆也在集合里，集合里的元素对乘法依然是封闭的，把这些元素组成的集合称为由元素的乘法作成的一个<strong>群</strong><a href="https://en.wikipedia.org/wiki/Group_(mathematics" target="_blank" rel="noopener">(group )</a>)也称为<strong>乘群</strong>。</p><p>此时群是针对集合上的一种运算而言，而有限域在集合上定义了两种运算，运算的封闭性是它们都有的重要性质。</p><p>观察群$\mathbb{F}^{\ast}_5$,对于群里面只有乘法运算$\times$,我们对其中的一个元素$2$作连续的累乘运算，即乘方运算,得到结果如下:</p><div class="note default"><p>$2^0=1\bmod5$<br>$2^1=2\bmod5$<br>$2^2=2\times2=4\bmod5$<br>$2^3=2\times2\times2=3\bmod5$<br>$2^4=2\times2\times2\times2=1\bmod5$<br>$2^5=2\times2\times2\times2\times2=2\bmod5$</p></div><p>通过计算发现这样几个规律:</p><div class="note info"><ol><li>$2^4=1$,而再进行一次计算$2^5$又变回了元素自身。</li><li>在对2作乘方运算时，计算结果实际上得到了$\mathbb{F}^{\ast}_5$上的所有元素。</li></ol></div><p>我们把群里某个元素进行群上所定义的的运算若干次后得到单位元的最小的次数叫做<strong>元素的阶</strong>。</p><p>通过运算可以得到群上所有元素的群称为<strong>循环群</strong>，而其中能生成所有元素的元叫做这个循环群的<strong>生成元</strong>。群中元素的个数叫做<strong>群的阶</strong>。</p><p>生成元元素的阶和群的阶是一样的。一个循环群的生成元不止一个，例如：3也是$\mathbb{F}^{\ast}_5$的一个生成元。</p><p>有限域$\mathbb{F}_5$作成的群的一个生成元是2，此时也把这个生成元叫做的这个有限域的一个<strong>本原元</strong><a href="https://en.wikipedia.org/wiki/Primitive_element_(finite_field" target="_blank" rel="noopener">(primitve element)</a>)。</p><p>如果一个群是循环群，那么群上的任意元素可由生成元通过若干次群上的运算得到，比如$\mathbb{F}^*_5$中的元素3,而2是群上的一个生成元满足$2^3\bmod 5=3$，称3对于生成元2的离散对数为3。</p><p>即使$2^7=128\bmod5=3$但是7不是一个解，因为2的阶为4，所以$2^4=1\bmod5$,因此$2^7=2^3\times2^4=3\times1\bmod5$，所以7这里和3其实是等价的只需要模上阶4。</p><p>有限域上的离散对数问题，是指对于有限域上的一个本原元$x$(即有限域中非零元对于乘法作成的群的生成元)，已知另一个有限域上的元素$y$,求解$x^{\alpha}=y \bmod p$中$\alpha$的问题，在有限域上这是困难的。</p><p>DH加密算法使用了这个原理，如果将方程中的$\alpha$作为私钥，发布出公钥$y$的话，通过域的本原元求解$\alpha$是困难的，这就保证了私钥的安全性。同样椭圆曲线密码中也用了类似的设计思路，只不过，它所定义的群，以及运算跟上面的乘法运算有些不同。</p><hr><h2 id="椭圆曲线"><a href="#椭圆曲线" class="headerlink" title="椭圆曲线"></a>椭圆曲线</h2><p><strong>椭圆曲线</strong><a href="http://mathworld.wolfram.com/EllipticCurve.html" target="_blank" rel="noopener">(elliptic curve)</a>是指由下面的这样的一类方程$y^2=x^3+ax+b$所描述的所有点组成的集合, 其中x,y可以取任何值，因此直观上来看它就是一条连续的曲线,下图是以太坊使用的椭圆曲线$y^2=x^3+7$在实数上的连续曲线secp256k1:</p><blockquote><p><img src="http://wx4.sinaimg.cn/mw690/844f0132gy1furlbsoeacj20bp0bp3yt.jpg" alt="@以太坊使用的椭圆曲线y^2=x^3+7在有限域F_59上即x,y={0,1,...,58}上的点的分布 | center | 200x200"></p></blockquote><p>密码算法中椭圆曲线定义在有限域$\mathbb{F}^*_p$上，方程中的$x,y$都取自有限域中的整数，此时曲线就不再是一条连续的了。事实上，它是一些离散点的集合，但所有点$(x,y)$都满足椭圆曲线的方程。</p><p>以太坊使用的椭圆曲线$y^2=x^3+7$在有限域$\mathbb{F}^{\ast}_{59}$上的点的分布：</p><blockquote><p><img src="http://wx4.sinaimg.cn/mw690/844f0132gy1furlbirv08j20bp0bqmxg.jpg" alt="@以太坊使用的椭圆曲线y^2=x^3+7在有限域F_59上即x,y={0,1,...,58}上的点的分布 | center | 200x200"></p></blockquote><p>椭圆曲线上的离散对数问题，也是对于定义在有限域上的椭圆曲线的点的集合来说的，这些点组成的集合也有群一样的性质，所以也可以定义”离散对数“。</p><hr><h3 id="椭圆曲线上的运算"><a href="#椭圆曲线上的运算" class="headerlink" title="椭圆曲线上的运算"></a>椭圆曲线上的运算</h3><p>椭圆曲线上所有的点组成的集合，定义一个运算称为加法，需要保证元素对加法运算是封闭的，并且有生成元，作成一个循环群。</p><p>首先，先定义一个无穷远的点O作为零点，它的作用和乘法群中1是类似的也是单位元。</p><p>假设有三个点$P,Q,R$有下面的定义:</p><div class="note info"><p>单位元: O 即定义的无穷远处的点。<br>逆运算: 若$P(x,y)$则$-P=(x,-y)$即将点作关于x轴的对称即为加法计算的逆运算。立即得到:<br>$P+(-P)=(x,y)+(x,-y)=O$在曲线上这两个点相连垂直于x轴指向无穷远与我们的定义符合。<br>加法: 若曲线上的三个点满足$P+Q+R=O$则$P+Q=-R$ 。</p></div><p>直观上，椭圆曲线上的两个点所确定的直线与椭圆曲线交于第三个点，指向无穷远处，而单位元的定义满足$R-R=O$所以$P+Q=-R$，这样椭圆曲线上所有点做成群。</p><hr><h4 id="加法计算"><a href="#加法计算" class="headerlink" title="加法计算"></a>加法计算</h4><p>在有限域上，椭圆曲线上的点是离散，此时直线可能并不是“直”的，但是只要三个点$P,Q,R$满足某一个直线方程$ax+by+c=0$，就称它们在同一条直线上。</p><p>在计算椭圆曲线上的加法时，就通过求解直线与椭圆曲线的方程组得到结果。</p><p>计算椭圆曲线上点的和公式为:</p><div class="note default"><p>已知点$P(x_p,y_p)$,$Q(x_q,y_q)$，设$R(x_r,y_r)$,椭圆曲线为$y^2 = x^3 +ax+b$由上面的加法定义$P+Q=-R$,和可以由如下计算得到：<br>\begin{array}{rl}<br>    \lambda&amp;=&amp;\frac{y_q-y_p}{x_q-x_p}\<br>  x_r &amp; = &amp; (\lambda^2 - x_p - x_q) \bmod{p} \<br>  y_r &amp; = &amp; [y_p + \lambda(x_r - x_p)] \bmod{p} \<br>  &amp; = &amp; [y_q + \lambda(x_r - x_q)] \bmod{p}<br>\end{array}<br>若$P=Q$则此时相当与计算$2P$那么上面的计算中：$$\lambda=\frac{3x_p^2+a}{2y_p}$$其中$a$是椭圆曲线方程中的参数。</p></div><p>定义了椭圆曲线上点的加法计算，那么椭圆曲线的数乘计算也能很容易得到，如:$$kP=P+\cdots +P$$而$2P$的计算比较特殊，可以先把偶数倍数乘结果计算出来，最后再做与$P$的加法。</p><hr><h3 id="椭圆曲线群的阶"><a href="#椭圆曲线群的阶" class="headerlink" title="椭圆曲线群的阶"></a>椭圆曲线群的阶</h3><p>椭圆曲线在有限域上所有点的个数叫做它的阶。</p><p>以$\mathbb{F}_{23}$上的椭圆曲线$y^2=x^3+7$为例，将有限域上的元素逐一代入曲线计算得到所有椭圆曲线上的点: </p><div class="note default"><p>( 1 ,10) ( 9  ,0 ) ( 16 ,20)<br>( 1 ,13) ( 10 ,8 ) ( 19 ,9 )<br>( 4 ,5 ) ( 10 ,15) ( 19 ,14)<br>( 4 ,18) ( 11 ,2 ) ( 20 ,7 )<br>( 6 ,4 ) ( 11 ,21) ( 20 ,16)<br>( 6 ,19) ( 15 ,1 ) ( 22 ,11)<br>( 8 ,6 ) ( 15 ,22) ( 22 ,12)<br>( 8 ,17) ( 16 ,3 )   O</p></div><p> 椭圆曲线上一共有23个点加上零元O，此时椭圆曲线对于加法作成的群的阶为24。</p><p>以(1,10)为例，它的具体计算过程为:</p><div class="note info"><ol><li>将$x=1$代入方程$y^2=x^3+7$得到$y^2=8\bmod23$</li><li>此时计算都在$\mathbb{F}_{23}$上,所以结果模23。</li><li>在$\mathbb{F}_{23}$上遍历得到结果，解得$y=10,13$。</li></ol></div><p>GO语言代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calPoint</span><span class="params">(field, a, b <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">          <span class="keyword">var</span> k <span class="keyword">int</span></span><br><span class="line">          <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; field; i++ &#123;</span><br><span class="line">                 x_tri := i * i * i</span><br><span class="line">                 y_square := (x_tri + a*i + b) % <span class="number">23</span></span><br><span class="line">                 <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; field; j++ &#123;</span><br><span class="line">                         temp := (j * j) % field</span><br><span class="line">                         <span class="keyword">if</span> temp == y_square &#123;</span><br><span class="line">                                 fmt.Println(<span class="string">"("</span>, i, j, <span class="string">")"</span>)</span><br><span class="line">                                 k++</span><br><span class="line">                         &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         fmt.Println(<span class="string">"Order is:"</span>, k+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>当有限域取特别大时，遍历的方法就不能么有效了，通常用<a href="https://en.wikipedia.org/wiki/Schoof%27s_algorithm" target="_blank" rel="noopener">Schoof’s algorithm</a>来计算椭圆曲线的阶。</p><p>任意选取两个点使用公式来计算两点的和:</p><div class="note default"><p>点$P(1,10)$,$Q(4,5)$计算$-R=(x_r,-y_r)$<br>先计算 $$\lambda=\frac{5-10}{4-1}=-5\times(-3)^{-1}=18\times15\bmod23=17$$<br>然后    \begin{array}{rl}x_r&amp;=(17^2-1-4)\bmod23=8\<br>         y_r&amp;=10+17(8-1)=(10-119)\bmod23=6<br>         \end{array}<br>         所以$(1,10)+(4,5)=(8,17)$也在椭圆曲线群上。</p></div><p>上述的加法运算，也验证了椭圆曲线上的所有点对于定义的加法运算是封闭的。</p><hr><h4 id="椭圆曲线群的循环性质"><a href="#椭圆曲线群的循环性质" class="headerlink" title="椭圆曲线群的循环性质"></a>椭圆曲线群的循环性质</h4><p>对于同一个点，连续的做加法运算即数乘运算可以得到同循环群类似的性质。<br>取$P(1,10)$依次计算:</p><div class="note default"><p>$0P=O$<br>$1P=P=(1,10)$<br>$2P=P+P=(22,11)$ $\lambda=\frac{3}{20}=22$<br>$3P=2P+P=(6,4)$       $\lambda=11$<br>$4P=2P+2P=(11,2)$ $\lambda=\frac{3}{22}=20$<br>$5P=4P+P=(19,9)$  $\lambda=13$<br>$6P=3P+3P=(15,1)$ $\lambda=2$<br>$8P=(4,5)$ $\lambda=16$<br>$12P=(9,0)$ $\lambda=4$<br>$\cdots$<br>$24P=12P+12P=O$</p></div><p>对于点$P(0,1)$作数乘运算之后$24P=O$ , 并且它也的数乘结果也得到了椭圆曲线群上的所有点，因此元素$P(0,1)$的阶为24，它的阶与椭圆曲线的阶一样，所以它是这个群的生成元。</p><p>椭圆曲线的所有点作成的也是一个循环群，把它的生成元称作椭圆曲线的<strong>基点</strong>。</p><p>椭圆曲线上的不同点的阶也不同，它们的值为满足$nP=O$的最小正整数。数值上为椭圆曲线阶的因子。例如：上面的曲线的阶为24那么椭圆曲线群上的点的阶为$1,2,3,4,6,8,12,24$，上面的计算中就得到了$24P=O$。</p><hr><h3 id="椭圆曲线的基点"><a href="#椭圆曲线的基点" class="headerlink" title="椭圆曲线的基点"></a>椭圆曲线的基点</h3><p>椭圆曲线算法首先要计算出椭圆曲线的阶$N$，即椭圆曲线在一个大的有限域$\mathbb{F}_p$上的点的个数。</p><p>假设椭圆曲线上某个点阶为$n$,那么满足$N/n=h$，其中$h$是一个整数。则对于基点$P$满足$(n*h)P=O$ 。</p><p>根据$N$的情况有如下两种结果:</p><div class="note info"><p>如果$N$为一个素数，那么它的任意非零点都是它的基点。</p></div><p>因为如果$N$为素数的话那么，椭圆曲线上的点的阶就为$1$或者$N$,只要找到一个阶不为$1$的点就可以作为这个椭圆曲线的基点。</p><div class="note info"><p>如果$N$是一个合数，存在一个点$X$的阶为$n$,满足$nhX=O$,由于在密码学上$N$的选取非常大，可能找不到$h=1$时，正好满足$NX=O$的点来当做我们的基点，因此只要选取$N$的因子中的一个充分大的素数且满足$nhX=O$。</p></div><p>计算$hX$后的点$Y$的阶为$n$,由$Y$作和则能得到$n$个点且满足$nY=O$,$Y$也就是它们的基点，用1中的方法只要$hX\neq O$,那么得到的点阶为$n$。可以用来生成$n$个不同的点。</p><hr><h3 id="椭圆曲线上的离散对数问题"><a href="#椭圆曲线上的离散对数问题" class="headerlink" title="椭圆曲线上的离散对数问题"></a>椭圆曲线上的离散对数问题</h3><p>椭圆曲线上的任意点$Q$，可由基点$P$作若干次椭圆曲线群上加法得到，即有椭圆曲线所在的有限域上的某一个数$k$,满足$kP=Q$ 。</p><p>反之，如果知道椭圆曲线上的某一个点想要求$k$ , 就是椭圆曲线上的离散对数问题。这与之前群中的离散对数问题是很相似的，只不过群上定义的运算规则不同。</p><p>上面的例子中，$\mathbb{F}_{23}$上的椭圆曲线$y^2=x^3+7$的基点为$(1,10)$,任取整数$4$，计算得到$4\times(1,10)=(11,2)$。</p><p>反过来，如果知道$(11,2)$ ，求它是由基点经过多少次计算得到的,就是困难问题，除非穷举。因此在通过这样一种困难问题来设计椭圆曲线密码算法时，就可以公开生成的公钥同时不用担心人们可以通过公钥反推得到私钥，进而保证了密码的安全性。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;区块链中主要使用了公钥加密算法，具体为椭圆曲线加密及其算法。&lt;/p&gt;
&lt;p&gt;经常看到的如&lt;code&gt;ECC&lt;/code&gt;，&lt;code&gt;ECDH&lt;/code&gt;，&lt;code&gt;ECDSA&lt;/code&gt;，就是一系列与椭圆曲线有关的缩写。&lt;code&gt;ECC&lt;/code&gt;为椭圆曲线密码
      
    
    </summary>
    
      <category term="以太坊" scheme="http://ldlovezyh.cn/categories/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
    
      <category term="以太坊" scheme="http://ldlovezyh.cn/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/"/>
    
      <category term="GO" scheme="http://ldlovezyh.cn/tags/GO/"/>
    
      <category term="椭圆曲线加密" scheme="http://ldlovezyh.cn/tags/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Homomorphic encryption on neural networks-BPCryptoNet</title>
    <link href="http://ldlovezyh.cn/2017/11/20/BPCryptoNets/"/>
    <id>http://ldlovezyh.cn/2017/11/20/BPCryptoNets/</id>
    <published>2017-11-19T16:00:00.000Z</published>
    <updated>2019-03-06T14:32:45.071Z</updated>
    
    <content type="html"><![CDATA[<div class="row">    <embed src="3.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    <summary type="html">
    
      
      
        

	&lt;div class=&quot;row&quot;&gt;
    &lt;embed src=&quot;3.pdf&quot; width=&quot;100%&quot; height=&quot;550&quot; type=&quot;application/pdf&quot;&gt;
	&lt;/div&gt;




      
    
    </summary>
    
      <category term="同态加密,神经网络" scheme="http://ldlovezyh.cn/categories/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="密码学" scheme="http://ldlovezyh.cn/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="同态加密" scheme="http://ldlovezyh.cn/tags/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Machine Learning on Encrypted Data using the SEAL v2.2 library</title>
    <link href="http://ldlovezyh.cn/2017/11/02/Linear/"/>
    <id>http://ldlovezyh.cn/2017/11/02/Linear/</id>
    <published>2017-11-01T16:00:00.000Z</published>
    <updated>2019-03-06T14:34:02.301Z</updated>
    
    <content type="html"><![CDATA[<div class="row">    <embed src="2.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    <summary type="html">
    
      
      
        

	&lt;div class=&quot;row&quot;&gt;
    &lt;embed src=&quot;2.pdf&quot; width=&quot;100%&quot; height=&quot;550&quot; type=&quot;application/pdf&quot;&gt;
	&lt;/div&gt;




      
    
    </summary>
    
      <category term="同态加密" scheme="http://ldlovezyh.cn/categories/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/"/>
    
    
      <category term="密码学" scheme="http://ldlovezyh.cn/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="同态加密" scheme="http://ldlovezyh.cn/tags/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Ciphertexts retrieval and some possible optimizations</title>
    <link href="http://ldlovezyh.cn/2017/09/08/6.Data%20Retrieval/"/>
    <id>http://ldlovezyh.cn/2017/09/08/6.Data Retrieval/</id>
    <published>2017-09-07T16:00:00.000Z</published>
    <updated>2019-08-05T15:07:11.601Z</updated>
    
    <content type="html"><![CDATA[<p>  Recent days I read the paper SHIELD which introduces ciphertext retrieval using the variant of GSW scheme which is based on RLWE problem. I make an experiment based on GSW scheme and finally I get a correct result. During the process, I find two procedures which may help to compress the dimension of the ciphertexts and improve the computational efficiency. I get the result by comparing the SHIELD scheme with the GSW scheme.</p><h2 id="Ciphertext-retrieval"><a href="#Ciphertext-retrieval" class="headerlink" title="Ciphertext retrieval"></a>Ciphertext retrieval</h2><p>  The message space of GSW scheme is $\mathbb{Z}_2$, and in order to retrieve the correct ciphertexts which are matching to the key words, we have to compare the ciphertexts bit by bit due to limitation of the retrieval algorithm. In fact, it is sufficient to use a SHE scheme for retrieval because we only need several homomorphic multiplications and one addtion in the the subroutine. This is a trivial method of ciphertext retrieval because the keywords are not encrypted<br>so the information we retrival may reveal to others. The main subroutines are the following pseudocode:</p><p><img src="../../../../images/sheet1.png" alt=""></p><p>From the pseudocode, we cn find that at least one hommomorphic multiplication must be evaluated for every bit retrieval. For example, input $l$ bits keywords we need to evaluate the homomorphic multiplication at least $l$ times. So our scheme must have multiplication depth at least $l$. Another disadvantage is that the retrieval efficiency is very low. There are two There are two reasons for this. On the one hand, we can only retrieve the information bit by bit. So in order<br>to get the specific information, we need to get ciphertexts traversal. This is a high overhead computation. On the other hand, homomorphic multiplication afford a high overhead, because of the multiplication of high dimension matrixs and the Flatten procedure. The following are program design and experiment results:</p><p>(1) Parameter setting.</p><p>According to the scheme security indicated in the paper [GSW13] and our aim for 3-bit key words retrieval, in other words integers retrieval from $0$ to $8$. In order to achieve at least $2^{\lambda}$ security against known attacks for the LWE, and the requirement of $L$ multiplication depth of the GSW scheme, the ciphertexts with error of magnitude wihch can decrypt correctly must small than $q/8$. Thus we have $(N + 1)^{L} B &lt; q/8$, $B$ is the bound of error vector and $N =(n + 1) · l$ the dimension of ciphertexts. Besides, follow the analysis of Lindner and Peikert, for a security level of $\lambda$ bits, we need the lattice dimension $n &gt; \log q/B(\lambda + 10)/7.2$. For the LWE assumption, the joint distribution $(A, R · A)$ is computationally indistinguishable from uniform over $\mathbb{Z}_q^{m\times(n+1)\times\mathbb{Z}_q^{N\times (n+1)}}$ it suffices to take $m &gt; 2n\log q$, $m$ is the dimension of uniform matrix $R \in {0,1}^{N \times m}$. To sum up, we have such constraint conditions:</p><p>$$<br>\begin{cases}<br>(N+1)^LB  \\<br>n &gt; \log q/B(\lambda + 10)/7.2\\<br>m&gt;2n\log q<br>\end{cases}<br>$$</p><p>However, due to the lack of GMP library the C++ compiler can only deal with at most $64$ bit integers, So I choose such parameters for the GSW scheme which can retrieve $3$ bit integers correctly.</p><p>$$\begin{array} {l|c}parameter&amp;\mathbf{LWE}\\ \hline<br>\lambda &amp; - \\ \hline<br>L    &amp; 3 \\ \hline<br>q &amp; 2^{31}-1 \\ \hline<br>m &amp; 930 \\ \hline<br>n &amp;15 \\ \hline<br>B &amp;1<br>\end{array}<br>$$</p><p>(2) Running results</p><p>In the experiment, I encrypted $52$ ciphertexts and use the AND and NOT gate to retrieve keywords $111$. The first ciphertexts is the encryption of message $1$, which is used to evaluate NOT gate. Thus in the ciphertexts there are only $17$ patterns which are needed to compare. The run time of each procedure is in the following table.</p><p>$$\begin{array} {l|c}\mathbf{Procedure}&amp;\mathbf{Time}\\ \hline PublicKey Gen &amp; 30.098s \\ \hline Encryption(per bit)    &amp; 10.398s \\ \hline<br>Retrieval(3-bit word) &amp; 619.129s<br>\end{array}<br>$$</p><p>It takes a long time to retrieval only $3$ bit integer because of the high overhead, and through debugging I find that the long runtime due to the high overhead of matrix multiplication and the Flatten procedure.</p><h2 id="Optimizations"><a href="#Optimizations" class="headerlink" title="Optimizations"></a>Optimizations</h2><p>1)Compress ciphertexts.</p><p>As in the thesis [SHIELD15] it constructs the variant of GSW shceme based on RLWE and as opposed to $C_{N \times N}$ in the GSW scheme the ciphertexts in SHIELD have a smaller ciphertext. Here we review the encrypt procedure in GSW scheme. To encrypt a message $\mu \in \mathbb{Z}_2$ , sample a uniform matrix $R \in {0,1}^{N \times m}$ and output the ciphertext $C = Flatten(\mu · I_N +BitDecomp(R ·A)) \in \mathbb{Z}_q^{N\times N}$ . Compare the encryption procedure in SHIELD scheme, I find that the GSW type cipher can transform into smaller dimension ciphertexts. And the during transmission the new type ciphertexts need smaller storage and the security of the ciphertexts is proved.</p><p>Observed that:</p><p>$$<br>\begin{align}<br>C &amp;=Flatten(\mu \cdot I_N + BitDecomp(R \cdot A)) \in \mathbb{Z}_q^{N\times N}\\<br>BitDecomp^{-1}(C)&amp;=BitDecomp^{-1}(\mu \cdot I_N+ BitDecomp(R\cdot A))\\<br>C’&amp;= \mu \cdot BitDecomp^{-1}(I_N)+ R\cdot A \in \mathbb{Z}_q^{N\times(n+1)}<br>\end{align}<br>$$</p><p>Thus, during the transmitting procedure we can encode the fresh ciphertexts by $Bitdecomp^{−1}$ procedure and then evaluate the homomorphic calculation in the clouds this technique compress the ciphertexts by a factor of $l$. AS for the security of the ciphertexts $C′$ using the lemma in [Reg 05].</p><p>(2)Fast Sparse Matrix Multiplication</p><p>When to implement the retrieval algorithm, it needs to evaluate several matrix multiplications, because of the encryption alogrithm in GSW, we get the B-strongly bounded ciphertexts a huge sparse matrix and its elements are only $0$ or $1$. However, the matrix multiplication still takes a high overhead because it is $O(n^ 2)$ complexity due to its huge dimension. These sparse matrix also need much more storage space because it needs to save the useless $0$ elements. For faster matrix multiplication and smaller storage space, it is appropriate to use sparse matrix<br>techniques. A popular format of sparse matrix is compressed sparse row (CSR) format, CSR explicitly stores column indices and nonzero values in arrays indices and data. A third array of row pointers, ptr, takes the CSR representation. For an $M \times N$ matrix ptr has length $M + 1$. $ptr(0) = 0, ptr(i) = ptr(i − 1) + N$ ,where $N$ is the number of nonzero elements on the $(i − 1) − t$ row in the original matrix. $ptr(M + 1)$ is the number of nonzero elements in the matrix. The<br>following figure illustrates the CSR representation of a matrix :</p><p>$$<br>A=\begin{pmatrix}<br> 1&amp; 7 &amp; 0 &amp; 0 \\<br> 0&amp; 2 &amp;8 &amp; 0 \\<br>5&amp;  0&amp;3  &amp; 9 \\<br>0 &amp;6  &amp;0  &amp; 4<br>\end{pmatrix}<br>$$</p><p>$$<br>ptr=\begin{bmatrix}<br> 0&amp; 2 &amp;  4&amp; 7 &amp; 9<br>\end{bmatrix}<br>$$<br>$$<br>data=\begin{bmatrix}<br> 0&amp; 1 &amp;  1&amp; 2 &amp; 0&amp;2&amp;3&amp;1&amp;3<br>\end{bmatrix}<br>$$<br>$$<br>indices=\begin{bmatrix}<br> 1&amp; 7 &amp;  2&amp; 8 &amp; 5&amp;7&amp;9&amp;6&amp;4<br>\end{bmatrix}<br>$$</p><p>In the GSW scheme, the ciphertexts only have $0$ or $1$ elements so it is sufficient for the CSR representation of ciphertexts to omit the data array. In this way we transform a $M \times N$ binary sparse matrix into two arrays. In my experiment the sparsity is around $0.5$. So this method can’t save the storage space but it may improve the efficiency for multiplication.</p><p>(3) sorting</p><p>Base on the ciphertext retrieval, I add an extra ciphertext sort function, so that we can analyze the encrypt data much flexible, for example you can get the maximum and minimum number from the ciphertexts.</p><p>For the sorting algorithm, we can implement the $AND$ gate by homomorphic multiplication, and $XOR$ gate by homomorphic addition. However, it can’t calculate the addition of two 1-ciphertexts, because the message space is $\mathbb{Z}^2$ . I design the sorting algorithm on the basis of bubble sort. This sorting function has two parts:</p><p>I.Compare the MSB of two encrypt integers (binary format).</p><p>II. Swap the smaller integer with the bigger one.</p><p>In order to implement the first step, we need to compare the ciphertexts bit by bit, once the later ciphertext is bigger than the first one then go to the second step. Thus the first step equals to such a boolean function:</p><p>$$f(a,b)=b(1-a)+b(1-b)$$</p><p>which equals to such a boolean circuit:</p><p>$$f (a, b) = b AND (NOR a) XOR (b AND (NOR b)$$</p><p>And its truth table:</p><p>$$\begin{array} {l|lc}a&amp;b&amp;value\\ \hline 0 &amp; 0&amp;0 \\ \hline 0&amp; 1&amp;1 \\ \hline 1&amp;0&amp;0 \\ \hline<br>1&amp;1&amp;0<br>\end{array}<br>$$</p><p>Then we need to swap the two integers we define such a select function:</p><p>$$<br>f(c,a,b) =<br>\begin{cases}<br>a, &amp;\text{c = 1}  \\<br>b, &amp;\text{c = 0}<br>\end{cases}<br>$$</p><p>which is equal to such a boolean cicuit:</p><p>$$f (c, a, b) = (c AND a) XOR ((NOR c) AND b)$$</p><p>However, this algorithm is of high overhead compare $N $l-bit integers is about $O(N^2\log(l))$ complexity. I still builds the program, so I don’t get the running results yet.</p><p>The whole pdf:<a href="https://github.com/llllddd/Code-with-Seal" target="_blank" rel="noopener">https://github.com/llllddd/Code-with-Seal</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  Recent days I read the paper SHIELD which introduces ciphertext retrieval using the variant of GSW scheme which is based on RLWE proble
      
    
    </summary>
    
      <category term="同态加密" scheme="http://ldlovezyh.cn/categories/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/"/>
    
    
      <category term="同态加密" scheme="http://ldlovezyh.cn/tags/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>The Third Generation FHE Scheme(GSW)</title>
    <link href="http://ldlovezyh.cn/2017/04/09/5.GSW%20Scheme/"/>
    <id>http://ldlovezyh.cn/2017/04/09/5.GSW Scheme/</id>
    <published>2017-04-08T16:00:00.000Z</published>
    <updated>2018-08-30T10:27:16.215Z</updated>
    
    <content type="html"><![CDATA[<p>This thesis is published by Craig Gentry, Amit Sahai and Brent Waters: a 3rd generation fully homomorphic encryption scheme. They present a more effective and simple (leveled)FHE scheme based learning with error. In this work, a method called approximate eigenvector is used to construct a asymptotically faster FHE scheme with matrix addition and multiplication. A new technique called flatten is used to slow down the expansion of errors generated by homomorphic multiplication.</p><hr><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>Essentially, this cryptosystem is partly motivated by BGV’s FHE scheme, because in BGV’s encryption scheme after every arithmetic level especially multiplication the size of ciphertexts will expand with dimension $\Theta (n^2)$  and for the reason of compactness we need to relinearize the ciphertexts which is generalized as a <code></code>key switching’’ procedure in BGV’s scheme. However, key switching is an expensive step as every time to compress a processed ciphertext into a normal-sized n-dimension ciphertext the long ciphertext vector must multiply with a special $n\times \Theta (n^2)$ matrix which I introduced in the last summary: $\tau_{s_1\rightarrow s_2}=(\text{powersof2}(\textbf{s}_1)||\textbf{A})$. This is a expensive step for both calculating and storage.</p><p>Observing the flaws of the FHE scheme described by Brakerski, etc. they use a approximate eigenvector method for both encryption end encryption to support matrix addition and multiplication as well as $\texttt{Flatten}$ technique can keep the ciphertexts the same size after homomorphic calculations but with small coefficients. So that the key switching procedure can be eliminated and compare to the complexity of relinearization matrices with complexity $\Omega (n^3)$ the complexity of matrices multipication is $n^{2.3727}$ thus the FHE scheme will be faster. And natural operation of ciphertexts allow us to do homomorphic operations without evaluation key namely, the evaluator can do homomorphic operations without knowing the user’s public key at all. This proposition can be used to construct identity-based FHE scheme as well as a recent attribute-based FHE scheme. </p><hr><h2 id="Decrypt-by-approximate-eigenvector"><a href="#Decrypt-by-approximate-eigenvector" class="headerlink" title="Decrypt by approximate eigenvector"></a>Decrypt by approximate eigenvector</h2><p>As we mentioned above in this FHE scheme homomorphic operation is matrix addition and matrix multiplication, this works because a message ${\mu\in\mathbb{Z}_p }$ is encrypted as a $N \times N$ matrix ciphertext over $\mathbb{Z}_p$. In order to decrypt such a matrix ciphertext, a trick in linear algebra is used: if we set secret key $\stackrel{\rightarrow}{v}$ of the encryption scheme the approximate eigenvector of matrix $C $then we can say $C$ encrypts $\mu$ when $C\cdot\stackrel{\rightarrow}{v}=\mu\cdot\stackrel{\rightarrow}{v}+\stackrel{\rightarrow}{e}$ and compute $x=&lt; C_i,\stackrel{\rightarrow}{v}&gt;=\mu\cdot v_i+e_i$ to decrypt for $\mu=\left\lfloor x/v_i\right\rceil$. </p><p>Thus, it is easy to see that matrix addtion just double the errors for $C^+\cdot \stackrel{\rightarrow}{v}=(\mu_1+\mu_2)\cdot \stackrel{\rightarrow}{v}+(\stackrel{\rightarrow}{e}_1+\stackrel{\rightarrow}{e}_2)$ and for matrix multiplication we have $$C^\times\cdot \stackrel{\rightarrow}{v}= C_1\cdot(\mu_2\cdot \stackrel{\rightarrow}{v}+\stackrel{\rightarrow}{e}_2)=\mu_1\cdot\mu_2\cdot\stackrel{\rightarrow}{v}+\mu_2\cdot\stackrel{\rightarrow}{e}_1+C_1\cdot\stackrel{\rightarrow}{e}_2$$ </p><p>Errors from matrix multiplication come from the part $\mu_2\cdot\stackrel{\rightarrow}{e}_1+C_1\cdot\stackrel{\rightarrow}{e}_2$ and it is actually a large error vector because $C_1$ is a $N\times N$ matrix in $\mathbb{Z}_q$ the coefficient of $\stackrel{\rightarrow}{e}_2$ will be $N\cdot q$ at most. In short, in order to construct a FHE scheme we short to dcrease the magnitude of the error vector’s coefficients. However, the error vector is necessary, because the security of the scheme base on LWE problem. </p><hr><h2 id="Flattening-Ciphertexts"><a href="#Flattening-Ciphertexts" class="headerlink" title="Flattening Ciphertexts"></a>Flattening Ciphertexts</h2><p>As we see above $C_1$ contribute the most factor of error, to obtain a leveled FHE scheme the coefficients of the ciphertext $C$ must have a small magnitude thus ensuring better bounds on the growth of the error. A B-strongly-bounded cipher text is sufficient, namely, the associated message $\mu$ and coefficients of $C$ have magnitude at most 1, while the coefficients of the error $\stackrel{\rightarrow}{e}$ has at most $B$. Then after evaluating a circuit of depth $L $ the error of ciphertext has magnitude at most $(N+1)^LB$  In order to keep ciphertext strongly bounded a operation called flattening is described. It also has several subroutines like what we described in the last summary abot key switching, we recall them here:</p><div class="note info"><ol><li><p>$\texttt{BitDecomp}(\stackrel{\rightarrow}{a})=(a_{1,0},\ldots,a_{1,\left\lfloor \log_2q\right\rfloor},\ldots,a_{k,0},\ldots,a_{k,\left\lfloor \log_2q\right\rfloor})\in \mathbb{Z}_2^N$</p></li><li><p>$\texttt{BitDecomp}^{-1}(\stackrel{\rightarrow}{a’})=(\sum 2^j\cdot a_{1,j},\ldots,\sum 2^j\cdot a_{k,j})\in\mathbb{Z}^k$</p></li><li><p>$\texttt{Powersof2}(\stackrel{\rightarrow}{b})=(b_1,2b_1,\ldots,2^{\ell-1}b_1,\ldots,b_k,2b_k,\ldots,2^{\ell-1}b_k)\in\mathbb{Z}^N$</p></li></ol></div><p>From these three subroutines, it’s not difficult to see that the most direct way to make the coefficients of a vector or matrix small is to run $\texttt{Bitdecomp}$ so that all coefficients are in ${0,1}$ and then the ciphertext is B-strongly bounded indeed. However, the final aim of ciphertexts’ B-strongly bound is to decrease the magnitude of error produced by homomorphic multiplication the procedure of $\texttt{BitDecomp}$ will expand the dimension of vectors by a factor of $\left\lfloor \log_q\right\rfloor+1$ as well as procedure $\texttt{Powersoft2}$. </p><p>This disadvantage will lead to the expansion of the error and it also increases the need for storage. Thus, in order to meet the need of restricting the increase of errors we should keep the dimension of vectors unchanged. Observed that $\texttt{BitDecomp_{-1}}$ decrease the dimension as same as the increase by $\texttt{BitDecomp}$, the technique $\text{Flatten}(\stackrel{\rightarrow}{a}’)=\texttt{BitDecomp}(\texttt{BitDecomp}_{-1}(\stackrel{\rightarrow}{a}’)) $ make coefficients of vectors in ${0,1}$ with its dimension unchanged. The decryption of ciphertext is ensured by the good property of $\texttt{Flatten}$ that for any vector $\stackrel{\rightarrow}{a}’$, $\langle\stackrel{\rightarrow}{a}’,\texttt{Powersof2}(\stackrel{\rightarrow}{b}) \rangle=\langle\texttt{Flatten}(\stackrel{\rightarrow}{a}’), \texttt{Powersof2}(\stackrel{\rightarrow}{b})\rangle$. </p><hr><h2 id="Construction"><a href="#Construction" class="headerlink" title="Construction"></a>Construction</h2><p>In this scheme, we will only consider NAND gate: $C_3=I_N-C_1\cdot C_2$, because NAND gate is the most universal gate and can be used to build any other gates. And we usually consider the message space ${0,1}$ so that the error increase $(N+1)B$ and a NAND-based Boolean circuit could be used for further computations. Then we get the leveled FHE scheme:</p><div class="note default"><p><strong>Setup</strong>$(1^\lambda,1^L)$: $L$ is the multiplicative depth, $n=(\lambda,L)$, error distribution $\chi=\chi(\lambda,L)$  appropriately for LWE that achieves at least $2^\lambda$security against known attacks. $m=m(\lambda,L)=O(n\log_q)$</p><p><strong>SecretKeyGen</strong>: Sample $\stackrel{\rightarrow}{t}\leftarrow\mathbb{Z}_q$. Output $sk=\stackrel{\rightarrow}{s}=(1,-\stackrel{\rightarrow}{t})\in\mathbb{Z}_q^{n+1}$.Let $\stackrel{\rightarrow}{v}=\text{Powersof2}(\stackrel{\rightarrow}{s})$.</p><p><strong>PublicKeyGen</strong>: The public key $pk$=$\textbf{A}\in R_q^{m\times {(n+1)}}$, $\textbf{A}=(\stackrel{\rightarrow}{b}||\textbf{B})$ in which $\textbf{B}\leftarrow R_q^{m\times n}$ and set $\stackrel{\rightarrow}{b}:=\textbf{B}\stackrel{\rightarrow}{t}+\textbf{e}$($\textbf{e}\leftarrow \chi^m$). </p><p><strong>Encrypt</strong>: Message space is $\mu\in {0,1}$, sample $R\leftarrow {0,1}^{N\times m}$ and output the ciphertext $C$,<br>$$C=\text{Flatten}(\mu\cdot I_N+\text{BitDecomp}(R\cdot A))\in\mathbb{Z}_q^{N\times N}$$</p><p><strong>Decrypt</strong>: Let $v_i=2^i\in\left(q/4,q/2\right]$ and $C_i$ the i-th row of $C$. Then $x_i\leftarrow \langle C_i,\stackrel{\rightarrow}{v} \rangle$. Output $\mu’=\left\lfloor x_i/v_i\right\rceil$</p><p><strong>NAND</strong> $(C_1,C_2)$: $C^{NAND}=\text{flatten}(I_N-C_1\cdot C_2)$ and $$C^{NAND}\cdot \stackrel{\rightarrow}{v}=(I_N-C_1\cdot C_2)\cdot\stackrel{\rightarrow}{v}=(1-\mu_1\cdot\mu_2)\cdot\stackrel{\rightarrow}{v}-\mu_2\cdot\stackrel{\rightarrow}{e}_1-C_1\cdot\stackrel{\rightarrow}{e}_2$$ </p></div><p>Since $\mu_2\in{0,1}$, the error is increased by a factor of at most $N+1$ and the final ciphertext’s error will be bounded by $(N+1)^L\cdot B$.</p><hr><h2 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h2><p>The security argument is surprisingly simple. Consider $C’=\texttt{BitDecomp}^{-1}(C)$. Because $C$ is already the output of $\texttt{Flatten}$ it reveals nothing more than $C’$. Unpacking $C’$ to $\texttt{BitDecomp}^{-1}(\mu  \cdot  I_N) + R\cdot A$, note that $R\times A $ is statistically uniform by the leftover hash lemma for uniform $A$. Finally, $A$ is indistinguishable from a uniform by the decisional LWE assumption.</p><hr><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><p>This leveled FHE scheme without evaluate key make it possible for constructing an identity-based FHE scheme which is an open problem mentioned in previous works. And I think the message to take home of this scheme is that they find a proper method to decrease the coefficients of matrix without change it’s dimension. In BGV’s FHE scheme they change the dimension of key space with key switching and modulus switching to come to the aim of decreasing noise and in this scheme the change of ciphertext space make it possible to do a much natural homomorphic calculation without increasing the error sharply. </p><hr><p><strong>Reference</strong></p><p><a href="https://eprint.iacr.org/2013/340.pdf" target="_blank" rel="noopener">Homomorphic Encryption from Learning with Errors:Conceptually-Simpler, Asymptotically-Faster, Attribute-Based</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;This thesis is published by Craig Gentry, Amit Sahai and Brent Waters: a 3rd generation fully homomorphic encryption scheme. They present
      
    
    </summary>
    
      <category term="同态加密" scheme="http://ldlovezyh.cn/categories/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/"/>
    
    
      <category term="密码学" scheme="http://ldlovezyh.cn/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="同态加密" scheme="http://ldlovezyh.cn/tags/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>The Second Generation FHE Scheme(BGV)</title>
    <link href="http://ldlovezyh.cn/2017/03/15/4.BGV%20Scheme/"/>
    <id>http://ldlovezyh.cn/2017/03/15/4.BGV Scheme/</id>
    <published>2017-03-14T16:00:00.000Z</published>
    <updated>2018-08-30T10:27:06.526Z</updated>
    
    <content type="html"><![CDATA[<p>From the last thesis DGHV, We know that Gentry’s approach for constructing a FHE scheme is using a method called squashing the decryption circuit to make a SwHE scheme bootstrapple. In this thesis, Brakerski, etc. present a new approach to FHE based on GLWE without bootstrapping i.e. Key switching and modulus switching.   </p><hr><h2 id="SwHE-Scheme"><a href="#SwHE-Scheme" class="headerlink" title="SwHE Scheme"></a>SwHE Scheme</h2><p>As in Gentry’s blueprint, the first step is to construct a SwHE scheme which can evaluate “low-degree” operation polynomials homomorphically. Here we use the generalization of the SwHE scheme in BV11b.</p><p>Because the security of the scheme is based on GLWE which is a generalization consists of both LWE and RLWE.The definition of GLWE includes four parameters $n$,$f$,$q$,and$\chi$.LWE is simply GLWE instantiated with $d = 1$. RLWE is GLWE instantiated with n = 1. So the basic GLWE-based encryption scheme can be transformed into LWE-based encryption scheme or RLWE-based encryption scheme with different choices of parameters. </p><p>The scheme works as follows:</p><div class="note default"><p><strong>KeyGen</strong>: Let $\textbf{t}\leftarrow \chi^n$.Output $sk=\textbf{s}\leftarrow(1,\textbf{t})\in R_q^{n+1}$.The public key $pk$=$\textbf{A}\in R_q^{N\times {n+1}}$, $\textbf{A}=(\textbf{b}||\textbf{B})$ in which $\textbf{B}\leftarrow R_q^{N\times n}$ and set $\textbf{b}:=\textbf{B}\textbf{t}+2\textbf{e}$($\textbf{e}\leftarrow \chi^n$). </p><p><strong>Encrypt</strong>: Message space is $m\in R_2$, set $\textbf{m}:=(m,0,\ldots,0)\in R_q^{n+1}$, sample $\textbf{r}\leftarrow R_2^N$ and output the ciphertext $\textbf{c}:=\textbf{m}+ \textbf{A}^T\textbf{r}\in R_q^{n+1}$. </p><p><strong>Decrypt</strong> : Output $m=\left[ \left[\left\langle \textbf{c},\textbf{s}\right\rangle\right]_q \right]_2=\left[\left[(\textbf{m}^T+r^T\textbf{A}\cdot s\right]_q\right]_2=\left[\left[m+2\textbf{r}^T\textbf{e}\right]_q\right]_2=\left[m+2\textbf{r}^T\textbf{e}\right]_2$</p></div><hr><h2 id="Noise-Reduction"><a href="#Noise-Reduction" class="headerlink" title="Noise Reduction"></a>Noise Reduction</h2><p>Noise increases sharply after operation of ciphertexts in this symmetric encryption, in order to reduce the magnitude of the noise they construct a leveled-FHE scheme. Namely the noise of ciphertext is refreshed level by level after calculated, so the parameters of the scheme depend on the depth of the circuits. Like the re-encrypt procedure we need change the secret key every level and then refresh the ciphertexts. In this thesis they present two techniques to implement these two steps: Key switching and Modulus switching.</p><hr><h3 id="Key-switching"><a href="#Key-switching" class="headerlink" title="Key switching"></a>Key switching</h3><p>In order to reduce the dimension of the homomorphic multiplication of ciphertexts, Brakerski and Vaikuntanathan use a method called ` relinearization’  which I introduced in my first summary, $\textbf{c}_1=\textbf{Enc}(m_1,s_1),\textbf{c}_2=\textbf{Enc}(m_2,s_2)$, it’s because that the ciphertexts are ring elements, multiplication of these two ciphertexts  we get a new ciphertext represented by the coefficients of the linear equation $L^{long}$ and decryptable by the long tensored secret key $s_1\otimes s_2$.Through the relinearization method they are turned into a shorter ciphertext $\textbf{c}_2$ that is decryptable by another secret key $s_2$.</p><p>Essentially, this method transform a ciphertext $\textbf{c}=\textbf{Enc}(m,s)$  into another ciphertext $\textbf{c}’=\textbf{Enc}(m,s’)$. This generalization is called the generalization Key switching procedure. First this procedure includes two subroutines:</p><div class="note default"><ol><li><p><strong>BitDecomp</strong>$(\textbf{c},q)=(\textbf{u_0},\textbf{u_1},\ldots,\textbf{u}_{\left\lfloor \log q\right\rfloor})\in R_2^{n\cdot \left\lfloor \log q\right\rfloor}$ ,$\textbf{c}=\sum_{j=0}^{\left\lfloor \log q\right\rfloor} 2^j\cdot\textbf{u}_j$.</p></li><li><p><strong>Powersof2</strong>$(\textbf{s},q)=(\textbf{x},2\cdot\textbf{x},\ldots,2^{\left\lfloor \log q\right\rfloor}\cdot\textbf{x})\in R_q^{n\cdot \left\lfloor \log q\right\rfloor}$.  </p></li></ol></div><p>It’s not difficult to see that the BitDecomp step is to decompose every component $c_i$ of $\textbf{c}$ with the base of 2. Then the $n$ coefficients of $2^j$ composes the vector $\textbf{u}_j\in R_2^n$, finally we get $\left\lfloor \log q\right\rfloor$ vectors together, because the largest component of $\textbf{c}\in R_q^n$ can only be $q-1$.PowerSof2 step is just to multiply the vector $\textbf{s}\in R_q^n$ by the base $2^j,(1\leq j\leq \left\lfloor \log q\right\rfloor)$ so that we have the following equation:<br>$$\left\langle \text{BitDecomp}(\textbf{c},q),\text{Powersof2}(\textbf{s},q)\right\rangle=\left\langle \textbf{c},\textbf{s} \right\rangle\text{mod}q$$</p><p>The key switching procedure consists of two procedures too.</p><div class="note default"><ol><li><p>$\textbf{A}\leftarrow \text{PublicKeyGen}(s_2,N)$,$\textbf{A}\in R_q^{N\cdot n_2+1},N=n_1\cdot \left\lceil \text{log}q\right\rceil$.<br>$\tau_{s_1\rightarrow s_2}=B,B=(\text{powersof2}(\textbf{s}_1)||\textbf{A})$. </p></li><li><p><strong>SwitchKey</strong>$(\tau_{s_1\rightarrow s_2},\textbf{c}_1)$: $\textbf{c}_2=\text{BitDecomp}(\textbf{c}_1^T\cdot\textbf{B})$.</p></li></ol></div><p>In fact, the matrix $\textbf{A}$ basically consists of encryptions of 0 under the key $\textbf{s}_2$, so in some sense, the matrix $\textbf{B}$ consists of encryptions of pieces of $\textbf{s}_1$ under the key $\textbf{s}_2$. This procedure transform a ciphertext $\textbf{c}_1$ encrypted by $\textbf{s}_1$ into another ciphertext $\textbf{c}_2$ encrypted by $\textbf{s}_2$. The correctness of the processes is guaranteed by: $$\left\langle \textbf{c}_2,\textbf{s}_2\right\rangle=2\left\langle \text{BitDecomp}(\textbf{c}_1),\textbf{e}_2\right\rangle+\left\langle \textbf{c}_1,\textbf{s}_1\right\rangle \text{mod}q$$</p><hr><h3 id="Modulus-switching"><a href="#Modulus-switching" class="headerlink" title="Modulus switching"></a>Modulus switching</h3><p>The second amazing technique for reduce the noise of ciphertexts calculated from the last level arithmetic circuit is called modulus switching. As we can see above in the decryption step of the SwHE scheme, after several operations the noise $\left[\left\langle \textbf{c},\textbf{s}\right\rangle\right]_q$ is greater then the upper bound. </p><p>However, through modulus switching we can change the inner modulus in the decryption equation to $\left[\left\langle \textbf{c}’,\textbf{s}\right\rangle\right]_p$ where $\textbf{c}’$ is closest to $(p/q )\cdot\textbf{c}$ such that $\textbf{c}’=\textbf{c}\text{mod}2$. Concretely, it maintain these two properties:$$\left[\left\langle \textbf{c}’,\textbf{s}\right\rangle\right]_p=\left[\left\langle \textbf{c},\textbf{s}\right\rangle\right]_q \text{mod}2$$<br>$$\left|\left[\left\langle \textbf{c}’,\textbf{s}\right\rangle\right]_p\right|&lt;(p/q)\cdot\left|\left[\left\langle \textbf{c},\textbf{s}\right\rangle\right]_q\right|+\ell_1(\textbf{s})$$</p><p>From above we can see modulus switching will change the size of ciphertexts and size of modulus. And the magnitude of the noise is depend on the modulus $p$(i.e., noise $e_p=\left[\left\langle \textbf{c}’,\textbf{s}\right\rangle\right]_p&lt;p/2$), so if $p$ is smaller than $q$ and $\textbf{s}$ has coefficients that are small in relation to $q$ then we can reduce the magnitude of the noise without knowing the secret key. </p><p>So choose a ladder of gradually decreasing moduli and use the properties above repeatedly. The noise of ciphertexts will decrease gradually, in fact, through modulus switching the noise is reduced by a fixed ratio and the noise is essentially kept constant. So, it’s help to increase the number of multiplicative levels that can be evaluated by an exponential factor. However, modulus size can’t be decreased without any limits, after polynomial times operation the noise will reach to the noise ceiling in the end. So, the leveled FHE without bootstrapping will be bounded by the maximum depth of circuits that can be evaluated, and parameters of this encryption scheme will depend on the level.</p><hr><h2 id="Leveled-FHE"><a href="#Leveled-FHE" class="headerlink" title="Leveled FHE"></a>Leveled FHE</h2><p>Using these two techniques above ciphertexts can be refreshed after every level arithmetic circuit to reduce the the magnitude of the noise so that a leveled FHE scheme is gained by adding the refresh procedure to the SwHE scheme. In the refresh procedure of the scheme, we first use key switching change the $i+1$ level ciphertext $\textbf{c}$ encrypted by $\textbf{s}_{i+1}$ into a ciphertext $\textbf{c}’$ encrypted by $\textbf{s}_i$. Then we can do module switching to reduce the noise without changing secret key but the inner modulus. </p><p>So we can run the arithmetic circuit to level 0 all the time and output the final cipertexts which can be decrypted correctly. However, in RLWE setting the length of ciphertexts output by the arithmetic circuits is depend on the circuit levels, for compactness they show a method to break an $GLWE_{n,x^d+1,q,\chi}$ into two $GLWE_{2n,x^{d/2}+1,q,\chi}$-dimension is decreased from $d$ to $d/2$ and length increase form $n$to $2n$. So the dimension of ciphertexts can be kept independent and in order to reduce length of the processed ciphertext the message is encoded in even coefficients so decrypt even coefficients of the ciphertexts is enough, essentially, the length of ciphertexts is still $n$. Finally, a leveled FHE can be got without bootstrapping based on RLWE. </p><hr><h3 id="Parameters-Restriction"><a href="#Parameters-Restriction" class="headerlink" title="Parameters Restriction"></a>Parameters Restriction</h3><p>For correctness of this leveled FHE scheme, it is sufficient to set proper parameters of the scheme to ensure that the noise produced by encryption and evaluation is smaller than the global noise bound $B$, namely, the maximum length of noise that the scheme can decrypt correctly. So, calculate the noise produced by every step of the scheme and put them together to look for which parameters influence the final noise and give proper setting to these parameters to ensure the ciphertext can be decrypted correctly. </p><p>The following is the result of related calculation:</p><div class="note default"><p>$ (q_{j-1}/q{j})\cdot(\gamma_R\cdot B^2+\eta_{\text{ SwitchKey},j})+\eta_{ \text{Scale},j} $<br>$&lt; (q_{j-1}/q{j})\cdot\gamma_R\cdot B^2 +\eta_{ \text{Scale},j}+\eta_{\text{ SwitchKey},j}$<br>$\leq \frac{1}{2\cdot B\cdot \gamma_R}\cdot \gamma_R\cdot B^2+\frac{1}{2}\cdot B$<br>$\leq B$</p></div><p>So, it only remains to set the ladder of moduli ($q_j$) and B, and the largest modulus used in this scheme is $\theta (L\cdot (\text{log}\lambda+\text{log}L))$ bits.</p><hr><h3 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h3><p>The security of this leveled FHE is IND-CPA, namely, semantic secure. The proof of the security is follow by a standard hybrid argument from the security of the SwHE scheme. The probability of the CPA adversary to win the Hybrid game which is similar to the IND-CPA game is negl($\lambda$)</p><p>As the leveled FHE is limited by the depth of arithmetic circuit, the optimization of bootstrapping with circular security assumption can help perform homomorphic evaluations without a bound of circuit levels. In order to improve the efficiency of evaluating, batching the bootstrapping operation is a reasonable method. That is to decompose a ring $R_p$ to the direct sum of some ring ideals $R_{\mathfrak{p}_i}$.</p><p>By Chinese remainder theorem $R_p \cong R_{\mathfrak{p_1}}\oplus \cdots \oplus R_{\mathfrak{p_d}}$ so that evaluating a function once over $R_p$ implicitly evaluates the function many times in parallel over the smaller plaintext spaces.</p><hr><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><p>The core procedure of the FHE scheme is the refresh step which consists of two techniques. These two tricks are very impressive and they dose reduce the noise. And I learn the difference between SwHE, Leveled-FHE and FHE.   However, as I know，Helib can implement the BGV scheme thus，I don’t know any thing about that so it is still remain many things for us to do.  </p><hr><p><strong>Reference</strong></p><p><a href="https://eprint.iacr.org/2011/277.pdf" target="_blank" rel="noopener"> (Leveled) Fully Homomorphic Encryption without Bootstrapping</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;From the last thesis DGHV, We know that Gentry’s approach for constructing a FHE scheme is using a method called squashing the decryption
      
    
    </summary>
    
      <category term="同态加密" scheme="http://ldlovezyh.cn/categories/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/"/>
    
    
      <category term="密码学" scheme="http://ldlovezyh.cn/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="同态加密" scheme="http://ldlovezyh.cn/tags/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Fully Homomorphic Encryption Over Integers</title>
    <link href="http://ldlovezyh.cn/2017/03/04/3.Fully+Homomorphic%20Encryption%20over%20the%20Integers/"/>
    <id>http://ldlovezyh.cn/2017/03/04/3.Fully+Homomorphic Encryption over the Integers/</id>
    <published>2017-03-03T16:00:00.000Z</published>
    <updated>2018-08-30T10:26:57.962Z</updated>
    
    <content type="html"><![CDATA[<p>This thesis describes a SwHE encryption scheme and it is transformed into a FHE scheme base on Gentry’s bootstrap technique. Operations of the scheme is over integers instead of working with ideal lattices over a polynomial ring. Usually, we call this encryption scheme DGHV scheme because it is developed by Dijk, Gentry, Halevi and Vaikuntanathan.</p><hr><h2 id="A-Simple-Symmetric-Encryption-Scheme"><a href="#A-Simple-Symmetric-Encryption-Scheme" class="headerlink" title="A Simple Symmetric Encryption Scheme"></a>A Simple Symmetric Encryption Scheme</h2><p>To begin with, they introduce a simple symmetric encryption scheme with modular exponentiation :<br>The plaintext space of the scheme is ${0,1}$ and cipertext space is $\mathbb{Z}$.</p><div class="note default"><p><strong>Encrypt</strong>$(p,m)$: $c=m+pq+2r$</p><p><strong>Decrypt</strong>$(p,c)$: $m=(c\text{mod}p)\text{mod}2=(c-p\ast\lceil c/p \rfloor)\text{mod}2$</p></div><p>This scheme is very easy to understand for us. Cipher $c$ modulo $p$ then $q$ is eliminate and modulo 2 then 2r is eliminate so we get the message $m$. There many prior works involved this scheme, however they don’t observe that the scheme could support multiplicative homomorphism and their encrypyion scheme is delicate with attacks. Thus modifications of this symmetric encryption scheme is on the analysis of its flaws. </p><hr><h3 id="Calculation-Proof"><a href="#Calculation-Proof" class="headerlink" title="Calculation Proof"></a>Calculation Proof</h3><p>As we can see, this is just an symmetric encryption scheme if we public the integer $pq$ then the secret key is revealed at once. In order to get a public key encryption scheme we need to reduce the security of this scheme to some hardness of math problem(i.e. approximate GCD problem). Can this symmetric encryption realize homomorphic calculation? We have following equations:</p><div class="note default"><p>$$c_1+c_2=(m_1+m_2)+p(q_1+q_2)+2(r_1+r_2)$$<br>$$c_1\ast c_2=(m_1+2r_1)\ast(m_2+2r_2)+p(m_1q_2+m_2q_1+pq_1q_2q_1r_2+2q_2r_1)$$</p></div><p>If decryption of these ciphertexts are $m_1+m_2$ and $m_1\ast m_2$, we can say it has correct homomorphic decryption. However, noise produced by multiplication is the product of both noise (i.e. $(m_1+2r_1)\ast(m_2+2r_2) $) and it increases quickly, but we need to keep the noise smaller than a bound $p/2$ so that we can get the correct decryption. Because of the bound of noise the scheme can support a limited number of additions and multiplications. </p><p>Due to the negative factors above, there are two works for converting this symmetric encryption scheme into a FHE scheme. First, they construct a SwHE scheme by generating a public key which consists of many “encryptions of zero” (i.e $x_i=pq_i+r_i$) and reduce the security of the symmetric scheme to the hardness of the approximate integer greatest common divisor problem(Approximate GCD problem).</p><p>Then using Gentry’s technique “quash the decryption circuit” to get a bootstrapple scheme which can invoke Gentry’s bootstrapping theorem to obtain a FHE scheme.It’s necessary to mention that with appropriate choice of parameters, this scheme has good resistance to various attacks.</p><hr><h2 id="SwHE-Scheme"><a href="#SwHE-Scheme" class="headerlink" title="SwHE Scheme"></a>SwHE Scheme</h2><p>From the procedure of encryption, we can see zero is encrypted by $x_i=pq+2r$ and add them to the cipher don’t influence the decryption because decryption of $x_i$ is still zero. But we can public these random encryption of zeros because of the approximate GCD problem that is to say an attacker can’t get $p$ from $x_i$. Thus we get an pubic key encryption scheme. For somewhat homomorphic calculations there adding an extra procedure <strong>Evaluate</strong> which is a operating circuit that can be used for homomorphic calculations.</p><p>Because of limitation of depth of the circuit we still need to keep the noise produced by polynomials is smaller than $p/2$ (i.e. noise produced by $f(c_1,c_2,\ldots,c_t)$ is smaller than  $p/2$) and these polynomials are called permitted polynomials denoted by $\mathcal{P_{\varepsilon}}$ the set of circuits for these permitted polynomials is denoted by $\mathcal{C_{\varepsilon}}$. Once we construct a SwHE scheme it must be correct for $\mathcal{C_{\varepsilon}}$.</p><p>This SwHE scheme requires several parameters,The choice of these parameter values refer to many considerations. I think they are calculated when considering the noise bound and the defense of many attacks to the scheme. In short, there are four parameters for encryption context: $\rho$ is the bit-length of the noise , $\gamma$ is the bit-length of the integers in the public key, $\tau$ is the number of integers in the public key and $\eta$  is the bit-length of the secret key. </p><hr><h3 id="Construction"><a href="#Construction" class="headerlink" title="Construction"></a>Construction</h3><p>The following is the main construction of the scheme:</p><div class="note default"><p><strong>KeyGen</strong>$(\lambda)$: Secret key $p$ is a random $\eta$ bit integer. Public key $\text{pk}=&lt;x_0,x_1,\ldots,x_{\tau}&gt;$</p></div><p>$x_i$ is generated by random encryption of zeroes:<br>$$\mathcal{D_{\gamma,\rho}}(p)=\left(q\stackrel{\$}{\leftarrow}\mathbb{Z}\cap\left[0,2^{\lambda}/p\right),r\stackrel{\$}{\rightarrow}\mathbb{Z}\cap(-2^{\rho},2^{\rho}):x=pq+r\right)$$<br>we must keep $x_0$ odd.</p><div class="note default"><p><strong>Encrypt</strong> $(pk,m\in{0,1})$: $c=[m+2r+2\sum_{i\in S}x_i]_{x_0}$, $S\in {1,2\ldots,\tau}$</p></div><p>This step is the main difference from the symmetric encryption scheme. Through adding the encryption of zeroes we can reduce the security of this scheme to the hardness of the approximate GCD problem. Namely, given a set of integers $x_0,x_1,\ldots,x_t$ an attacker can’t find the common near divisor $p$. Thus we can public these integers as public key then we construct a public key encryption scheme.</p><div class="note default"><p><strong>Evaluate</strong> $(\text{pk},C,c_1,\ldots,c_t)$: $C(\mathcal{P_{\epsilon}}\in\mathcal{C_\epsilon}$ Calculate $c’=f(c_1,\ldots,c_t)$.</p></div><p>This step we implement homomorphic calculations on ciphers, however the problem of noise is still exist so $f\in\mathcal{P}_\epsilon$ the concrete degree $d$ of $f$ should rely on the bound of noise which must smaller than $p/2$ and in this scheme $d\leq\frac{\eta-4-\log\left|\vec{f}\right|}{\rho’+2}$ .So this scheme is just `somewhat’.</p><div class="note default"><p><strong>Decrypt</strong>$(sk,$c$)$:  $m’=(c\text{mod}p)\text{mod}2=(c\text{mod}2)\oplus(\left\lfloor c/p\right\rceil\text{mod}2)$</p></div><p>Decryption is similar to the symmetric version. We reduce the noise by modular arithmetic and we can find that encrypt same message $m$ may get different ciphers because of the randomness of $x_i$ but decryption of these ciphers is same. </p><hr><h3 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h3><p>Recall that the security of our SwHE scheme rely on the hardness of approximate GCD problem. Many attacks are described which can solve the approximate GCD problem. The choice of parameters in the SwHE scheme achieves at least $2^\lambda$  security against these attacks and I think there must exist better choice.</p><hr><h2 id="Fully-Homomorphic-Encryption"><a href="#Fully-Homomorphic-Encryption" class="headerlink" title="Fully Homomorphic Encryption"></a>Fully Homomorphic Encryption</h2><p>From this SwHE scheme they follow Gentry’s approach for constructing a FHE scheme. As we mentioned above calculations of ciphers increase the noise which may beyond the arithmetic depth of circuit and decryption can reduce the noise of ciphers so if we can decrypt the cipher before the result of homomorphic calculation up to the bound of noise thus we can do any calculations on the ciphers.</p><p> This strategy is called `homomorphic decryption’ specifically we add a augment decryption circuit named $D_\varepsilon(\lambda)$(r is the security parameter)to the SwHE scheme it’s obviously that if $D_\varepsilon(\lambda)\subseteq\mathcal{C}_\varepsilon(\lambda)$ the decryption circuit is feasible for the scheme. Thus we say that the encryption scheme $\varepsilon$ is bootstrappable and we can get a FHE scheme. However, we can’t use the secret key $p$ for the augment decryption circuit directly because it requires boolean circuits that are deeper than what the SwHE scheme can handle. </p><hr><h3 id="Construction-1"><a href="#Construction-1" class="headerlink" title="Construction"></a>Construction</h3><p>Hence, Gentry’s transformation to “squash the decryption circuit” is used. Specifically, they add to the public key some extra information about the secret key, and use this extra information to “post process” the ciphertext. The extra information in the public key does not help an attacker break the scheme because of hardness assumption of SSSP. The main part of the modified encryption scheme is as the follows:</p><div class="note default"><p><strong>KeyGen</strong>: $\text{sk}=\vec{s}$, $\text{pk}=(pk^\ast,\vec{y})$</p></div><p>Where $\vec{s}=\left\langle s_1,\ldots,s_\Theta\right\rangle$ and its hamming weight is $\theta$, $S={i:s_i=1}$. $\vec{y}=\left\langle y_1,\ldots,y_\Theta\right\rangle$ it contains information of secret key because $\left[\sum_{i\in S}y_i\right]_2=(1/p)-\triangle_p$.$S$ is a sparse set so attacker can’t know the secret key because of SSSP.</p><div class="note default"><p><strong>Encrypt &amp; Evaluate</strong>: Set $z_i\leftarrow\left[c^{\ast}\cdot y_i\right]_2,i\in{1,\ldots,\Theta}$ Output$(c^{\ast},\vec{z})$</p></div><p>This step can be considerate as expansion of ciphers where $z_i$ contains information about $p$(i.e. $\left[c^*/p\right]=\left\lfloor \sum s_iz_i\right\rfloor(\text{mod}2)$).</p><div class="note default"><p><strong>Decrypt</strong>: $m’=\left[c^*-\left\lfloor \sum_is_iz_i\right\rceil\right]_2$</p></div><p>In the thesis they prove that the modified scheme is also correct for $C(\mathcal{P_\varepsilon})$. And the modified decryption equation can be considerate as a permitted polynomial so we get the augmented (squashed) decryption circuits(i.e. $D_\varepsilon\subset C(\mathcal{P_\varepsilon})$).</p><hr><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><p>I write the main ideas of constructing a FHE scheme, in fact this thesis gives us a concrete application of Gentry’s technique which help me to understand FHE a lot. However,I don’t understand many details of the proof of bootstrapping so far, I think I need to work harder and read the paper repeatedly. </p><hr><p><strong>Reference</strong><br><a href="https://eprint.iacr.org/2009/616.pdf" target="_blank" rel="noopener">Fully Homomorphic Encryption over the Integers</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;This thesis describes a SwHE encryption scheme and it is transformed into a FHE scheme base on Gentry’s bootstrap technique. Operations o
      
    
    </summary>
    
      <category term="同态加密" scheme="http://ldlovezyh.cn/categories/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/"/>
    
    
      <category term="密码学" scheme="http://ldlovezyh.cn/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="同态加密" scheme="http://ldlovezyh.cn/tags/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Can Homomorphic Encryption be Practical</title>
    <link href="http://ldlovezyh.cn/2017/02/23/2.Can%20Homomorphic%20Encryption%20be%20Practica/"/>
    <id>http://ldlovezyh.cn/2017/02/23/2.Can Homomorphic Encryption be Practica/</id>
    <published>2017-02-22T16:00:00.000Z</published>
    <updated>2018-08-30T10:27:57.976Z</updated>
    
    <content type="html"><![CDATA[<p>This thesis is published by Kristin Lauter and Vinod Vaikuntanathan in 2011 the whole thesis briefly cotains three parts of contents including some potential applications of homomorphic encryption, a concrete implementation of somewhat homomorphic encryption scheme and some work in the future. I read all of them and feel a little confused about chosing parameters of the SHE scheme. </p><hr><h2 id="Applications-Scenarios"><a href="#Applications-Scenarios" class="headerlink" title="Applications Scenarios"></a>Applications Scenarios</h2><p>In the first part of this thesis, the author describes three rea-world applications, in the medical, financial and the aadvertising domains, which require only that the encryption scheme is <code></code>somewhat’’ homomorphic. </p><ol><li><p>In medical applications, there is a private cloud medical records storage system that can save data of patient’s encrypted medical record. With FHE, the cloud service can compute functions, (e.g.,averages, standard deviations or other  statistical function) on patient’s encrypted data and then send the patient updates, alerts, or recommendations based on the received data. In the process, the information of patient can only be known by the secret key. </p></li><li><p>However, in financial applications the data and the function to be computed on the data is private and proprietary. For example, to make investment decisions, a company must refer to the financial data which is private and the functions to do computations on this data may be proprietary. Thus, with FHE we can upload an encrypted version of the function to the cloud then cloud service can evaluates the private function by applying<br>the encrypted function to the encrypted data it receives. Thus, cloud returns the encrypted output to the company without knowing any information of data or function. </p></li><li><p>In advertising, the cosmetics company get the contextual information which is collected from e-mail or browser searches so that he can use contextual information to target advertising to potential customers. With FHE all the information of customer’s private data and the ads are encrypted thus, the cloud and the advertisers don’t learn anything about the consumer’s data. </p></li></ol><p>Nowadays, some of them have achieved such as precision advertising but its security is still uncertain. In these three application, by the bridge of homomorphic encryption schemethe people’s encrypted data in the cloud is open to the third party, then the third party do computations on encrypted data and feedback the results to people.</p><h2 id="Somewhat-Homomorphic-Encryption-Scheme"><a href="#Somewhat-Homomorphic-Encryption-Scheme" class="headerlink" title="Somewhat Homomorphic Encryption Scheme"></a>Somewhat Homomorphic Encryption Scheme</h2><p>In the second part of this thesis they show a implementation of the recent somewhat homomorphic encryption scheme of Brakerski and Vaikuntanathan using the computer algebra Magma. The somewhat homomorphic encryption scheme<br>$$\mathcal{SHE}=(SH.Keygen,SH.Enc,SH.Add,SH.Mult,SH.De)$$<br>based on $\text{RLWE}_{f,q,\chi}$ is ruled by a number of parameters.</p><hr><h3 id="The-Scheme"><a href="#The-Scheme" class="headerlink" title="The Scheme"></a>The Scheme</h3><div class="note default"><p><strong>SH Keygen</strong>$(1^k)$:  Sample a ring element $s\stackrel{\$}{\leftarrow}\chi$ and define the secret key $sk := s$. Sample a uniformly random ring element $a_1\leftarrow R_q$ and an error $e\leftarrow\chi$ then compute the public key$ pk := (a_0=-(a_1s+te),a_1)$.</p><p><strong>SH.Enc</strong>$(pk,m)$: Given the public key $pk=(a_0,a_1)$ and a message $m\in R_q$, the encryption algorithm samples $u\leftarrow\chi$, and $f,g\leftarrow\chi$, and computes the ciphertext<br>$$ct=(c_0,c_1):=(a_0u+tg+m,a_1u+tf)$$</p><p><strong>SH.Dec</strong>$(sk,\text{ct}=(c_0,c_1,\ldots,c_\delta))$: First compute $ m=\displaystyle\sum_{i=0}^{\delta} c_is^i\in R_q $ and then output the message as $ \tilde{m}\bmod  t$.</p><p><strong>SH.Add</strong>$(PK,\text{ct}_0,\text{ct}_1)$: Let $\text{ct}=(c_0,c_1,\ldots,c_\delta)$ and $\text{ct}’=(c_0,c_1,\ldots,c_\delta)$(If $\delta\neq\gamma$, pad the shorter ciphertext with zeroes).<br>$$\text{ct}_{add}=(c_0+c_0’,c_1+c_1’,\ldots,c_{max(\delta,\gamma)}+c’_{max}{(\delta,\gamma)}\in R_q^{max(\delta,\gamma)+1}$$</p><p><strong>SH.Mult</strong>$(PK,\text{ct}_0,\text{ct}_1)$: Let v be a <em>symbolic</em> variable and consider the expression:</p><p>$$(\sum_{i=0}^{\delta} c_iv^i)\cdot(\sum_{i=0}^{\delta}{c_i}’v^i)\equiv\sum_{i=0}^{\delta+\gamma}\hat c_i$$ </p><p>The output ciphertext is $\text{ct}_{mlt}=(\hat c_0,\ldots,\hat c_{\delta+\gamma})$. </p></div><p>In fact, this scheme is got from its symetric encryption version through adding nosie to the scheme from a discrete Gussian distribution and its secure under the Ring LWE assumption.</p><hr><h3 id="Relinearization"><a href="#Relinearization" class="headerlink" title="Relinearization"></a>Relinearization</h3><p>However, when calculating the homomorphic multipication the number of ring elements in a ciphertext will be increased. The author use a transformation called `relinearization’ that reduces the ciphertext back to two ring elements. The homomorphic multiplication generates a ciphertext $\text{ct}_mlt=(c_0,c_1,c_2)$,and they set $$c_1^{\text{relin}}:=c_1+\displaystyle\sum_{i=0}^{[log_tq]-1} c_{2,i}a_i\text{ and}$$$$c_0^{\text{relin}}:=c_0+\displaystyle\sum_{i=0}^{[log_tq]-1}c_{2,i}b_i$$  and then $c_0^{\text{relin}}+c_1^{\text{relin}}=t(e_{mult}-e_{relin})$, if the final eror $e_{mult}-e_{relin}$ is small enough then the relinearization mantain the correctness of decryption. </p><p>Since the ease of performing homomorphic operations depends crucially on the specific message-encoding used in the ciphertexts they describe two tricks for encoding messages:</p><ol><li><p>In order to make it effective for arithmetic operation, the author break break each $m$ into (at most $n$) bits $(m^{(0)},m^{(1)},\ldots,m^{(n-1)})$ and then encode the message $m$ as polynomials of degree at most $n-1$. Thus, after encryption of these messages their coefficients are still single. Namely, their sum can be calculated by sum of polynomials and their product can be calculated by product of polynomials and module $x^n+1$.</p></li><li><p>For packing many bits in a ciphertex, give n Ciphertexts $\text{ct_i}=(c_{0,i},c_{1,i})$ that encrypt the bits $b_i$, then</p></li></ol><p>$$\text{ct}_{\text{pack}}:=(\sum_ic_{0,i}x^i,\sum_ic_{1,i}x^i)$$</p><p>encrypts the polynomial $b(x)=b_0+\ldots+b_{n-1}x^{n-1}$. Thus we transform ciphertexts that encode $n$ bits into a single ciphertext.</p><p>For the parameters which rule the scheme, the author assess the security of their encryption scheme against the attacks and then they compute secure parameter choices for the scheme, and the results are summarized in Table 1.The chosen parametes provide asecurity of 128 bits or more against the  distinguishing attack with advantage $\epsilon=2^{-32}$.</p><hr><h3 id="Table-Analysis"><a href="#Table-Analysis" class="headerlink" title="Table Analysis"></a>Table Analysis</h3><p>As we can see from table 1 the choices of parameters $n$ (the dimension) and $log q$ (the bit-length of the modulus) for different values of $t$ (the message space modulus) and $D$ (the maximal degree for the polynomial whose homomorphic evaluation we can support). Their calculations show that both $n$ and $log q$ grow almost linearly in the  maximal ciphertext degree $D$. And then the ciphertext grows quadratically meantime the public key grows cubically.</p><p>Table 2 gives the running time of the encryption scheme toghter with Table 1 we can conclude that for different homomorphic operation the paramters of encryption scheme is also different. For example, to compute mean the maximal degree of ciphertext is $D=1$ the suitable parameters given in Table 1 is $t=1024$,$D=1$and$n=1024$.The cprresponding 30-bit prime is $q=1061093377$.</p><p>At the end of this thesis the authr give some future work including implementing fully homomorphic encryption and optimizing communication with the cloud.</p><hr><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><p>I write main points of the thesis above. This  encryption scheme can be transformed into FHE, I am still reading the related thesis. And from this thesis I learn that the addition and multiplication of the encrypted data will increase the error we add for LWE and the increasion of mutilication is notable. Once the error come to the safe bound our envryption scheme become unsafe. That is why we need to limit the depth of mutipication. Besides I know the `relinearization’ is a important method but there are still many details I need to read in other thesis.</p><hr><p><strong>Reference</strong> :</p><p><a href="https://eprint.iacr.org/2011/405.pdf" target="_blank" rel="noopener">Can Homomorphic Encryption be Practical?</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;This thesis is published by Kristin Lauter and Vinod Vaikuntanathan in 2011 the whole thesis briefly cotains three parts of contents incl
      
    
    </summary>
    
      <category term="同态加密" scheme="http://ldlovezyh.cn/categories/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/"/>
    
    
      <category term="密码学" scheme="http://ldlovezyh.cn/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="同态加密" scheme="http://ldlovezyh.cn/tags/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>What is Homomophic Gryptography</title>
    <link href="http://ldlovezyh.cn/2017/02/16/1.What%20is%20Homomophic%20Gryptography/"/>
    <id>http://ldlovezyh.cn/2017/02/16/1.What is Homomophic Gryptography/</id>
    <published>2017-02-15T16:00:00.000Z</published>
    <updated>2018-08-30T10:26:19.253Z</updated>
    
    <content type="html"><![CDATA[<p>After reading the first three chapters of Kevin Henry’s thesis(2008), I want to talk about my learning of homomorphic cryptography from three aspects. </p><hr><h2 id="What-Is-Homomorphic-Gryptography"><a href="#What-Is-Homomorphic-Gryptography" class="headerlink" title="What Is Homomorphic Gryptography ?"></a>What Is Homomorphic Gryptography ?</h2><p>The encryption function of homomorphic cryptosystems is a homomorphism so that it allows a third party to take two ciphertexts $e_K(m_1)$ and $e_K(m_2)$, and calculate one of $e_K(m_1+m_2)$ or $e_K(m_1\cdot m_2)$ without knowledge of any secret information. Usually, the plaintext space and the ciphertext space are groups or rings so that the cryptosystems can support one or two operations. We can regard the encryption as a mapping from the plaintext space to the ciphertext space. The following figure reflect the homomorphic properties.</p><div class="note info"><p>$P\stackrel{e_K}\longrightarrow C$<br>$p_1,p_2\qquad c_1=e_K(p_1),c_2=e_K(p_2)$<br>$p_1\cdot p_2\stackrel{e_K}\longrightarrow e_K(p_1\cdot p_2)=e_K(p_1)\otimes e_K(p_2)$</p></div><p>Through the figure we can see that given ciphertexts $c_1$,$c_2$ that encrypt $p_1,p_2$ under some key then we can calculate the encryption of $p_1\cdot p_2$ without knowledge of $p_1,p_2$. I want to note that $\cdot$ and $\otimes$ are different because of the operation between plaintexts is different from the operation between ciphertexts. In the third chapter of this thesis almost all homomorphic cryptosystems can only support one operation, linear operation or multiplication. So how to construct a homomorphic  cryptosystem that can support both linear operation and multiplication? </p><p>The birth of Gentry cryptosystem which named FHE is in this background. Through this crptosystem we can calculate arbitrary numbers of additions and multiplications on encrypted data. I want to make a brief introduction here. Given ciphertexts $c_1,\ldots,c_t$  that encrypt $p_1,\ldots,p_t$ under some key, that is $c_1=e_K(p_1),\ldots,c_t=e_K(p_t)$, then for any efficient computable function $f$ we can calculate a ciphertext that encrypts $f(p_1,\ldots,p_t)$under that key.</p><div class="note info"><p>$P\stackrel{e_K}\longrightarrow C$<br>$ p_1,\ldots,p_t c_1=e_K(p_1),\ldots,c_t=e_K(p_t)$<br>$f(p_1,\ldots,p_t)\stackrel{e_K}\longrightarrow e_K(f(p_1,\ldots,p_t))=f’(e_K(p_1),\ldots,e_K(p_t))$</p></div><hr><h2 id="Security-of-Homomorphic-cryptosystem"><a href="#Security-of-Homomorphic-cryptosystem" class="headerlink" title="Security of Homomorphic cryptosystem"></a>Security of Homomorphic cryptosystem</h2><p>Chapter 1 of this thesis tell us some notions of security. The usual method of demonstrating that a cryptosystem is secure is showing that if an adversary can invert the encryption function or break semantic security. Under this criterion we want a cryptosystem to be indistinguishable under different attacks, then we obtained three main security levels of the cryptosystem. The following is the relaitonship between these three security levels.</p><div class="note info"><p>$IND-CCA2\Rightarrow IND-CCA1\Rightarrow IND-CPA$<br>$IND-CPA\Leftrightarrow \text{Semantic Security Under}\ CPA$<br>$NM-CPA\Leftrightarrow IND-CCA2$</p></div><p>We can see that IND-CCA2 is the strongest security level of cryptosystems, however because of the malleablity of homomorphic cryptosystem, no homomorphic cryptosystem can be IND-CCA. How about IND-CCA1?Observed that in chapter 3, many homomorphic cryptosystems are just proved to be semantic secure because the security of them are based on the hardness of math problems.  Can they be IND-CCA1 ? or it’s difficult to construct a homomorphic cryptosystem to be IND-CCA?</p><p>In fact, under the assumption that the homomorphic operations are implemented in an ideal black box model we have such a theorem: IND-CCA1 is a tight upper bound for the security of a homomorphic cryptosystem. However, for an algorithm-based homomorphic cryptosystem IND-CCA1 is still an upper bound but not a tight upper bound. So there are alternate security notions for homomorphic cryptosystems which are weaken than IND-CCA2 but stronger than IND-CCA1. The following figure is the relationship between them.</p><div class="note info"><p>$ IND-CCA2\succ IND-gCCA2 \Leftrightarrow IND-rCCA2\succ IND-hCCA2\succ IND-CCA1$</p></div><p>For a homomorphic cryptosystem IND-gCCA2 and IND-rCCA2is still too strong to achieve, but in some cases IND-hCCA2 security can be achieved. It’s necessary to note that CCA2, gCCA2 and rCCA2 can be obtained as special cases of hCCA2.</p><hr><h2 id="Construction-of-Homomorphic-Cryptosystems"><a href="#Construction-of-Homomorphic-Cryptosystems" class="headerlink" title="Construction of Homomorphic Cryptosystems"></a>Construction of Homomorphic Cryptosystems</h2><p>In chapter 3 of this thesis the author give us a survey of homomorphic cryptosystems. All these homomorphic cryptosystems are built upon math problems and security assumption also depends on these math problems. On the one hand the difficulty of these math problems ensure the security of cryptosystems on the other hand these math problems also restrict the homomorphic operation for encrypted data. The following table is a summary of homomorphic cryptosystems which I excerpt from the thesis.</p><p><img src="http://wx1.sinaimg.cn/mw690/844f0132gy1furrfez1mfj20t40e0mzd.jpg" alt=""></p><p>In this table +,-,$\times_c$ are used to denote homomorphic addition, subtraction and multiplication on ciphertexts. We can regard them as linear operations. $\times$ is used to denote homomorphic multipication.</p><p>As we can see from this table, almost all cryptosystems can only support one homomorphic operations linear operation or multiplication because of the security assumption thus if we want to improve the homomorphic we must find better math problem to construct the cryptosystem. What makes me confused is the message expansion. Usually the ciphertext space is larger than the plaintext space so it causes the message expansion and the encryption method also causes message expansion. What problems will it bring to the cryptosystem? </p><p>In the thesis there is only one cryptosystem named BGN cryptosystem that can support both linear operations and multiplication. So FHE is a very important cryptosystem. And more details of these cryptosystems can be found in thesis. </p><hr><p><strong>Reference</strong>:</p><p><a href="https://uwspace.uwaterloo.ca/bitstream/handle/10012/3901/uw-ethesis.pdf?sequence=1" target="_blank" rel="noopener">The Theory and Applications ofHomomorphic Cryptography</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;After reading the first three chapters of Kevin Henry’s thesis(2008), I want to talk about my learning of homomorphic cryptography from t
      
    
    </summary>
    
      <category term="同态加密" scheme="http://ldlovezyh.cn/categories/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/"/>
    
    
      <category term="密码学" scheme="http://ldlovezyh.cn/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="同态加密" scheme="http://ldlovezyh.cn/tags/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
</feed>
